import {
  __commonJS
} from "./chunk-DZZM6G22.js";

// node_modules/phaser-raycaster/dist/phaser-raycaster.min.js
var require_phaser_raycaster_min = __commonJS({
  "node_modules/phaser-raycaster/dist/phaser-raycaster.min.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define("PhaserRaycaster", [], t) : "object" == typeof exports ? exports.PhaserRaycaster = t() : e.PhaserRaycaster = t();
    }(self, function() {
      return function() {
        var e = { 781: function(e2, t2, i2) {
          function n(e3) {
            return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            }, n(e3);
          }
          function r(e3, t3) {
            for (var i3 = 0; i3 < t3.length; i3++) {
              var n2 = t3[i3];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, s(n2.key), n2);
            }
          }
          function s(e3) {
            var t3 = function(e4, t4) {
              if ("object" != n(e4) || !e4) return e4;
              var i3 = e4[Symbol.toPrimitive];
              if (void 0 !== i3) {
                var r2 = i3.call(e4, t4 || "default");
                if ("object" != n(r2)) return r2;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return ("string" === t4 ? String : Number)(e4);
            }(e3, "string");
            return "symbol" == n(t3) ? t3 : t3 + "";
          }
          function o(e3, t3, i3) {
            return t3 = h(t3), function(e4, t4) {
              if (t4 && ("object" == n(t4) || "function" == typeof t4)) return t4;
              if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
              return function(e5) {
                if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e5;
              }(e4);
            }(e3, a() ? Reflect.construct(t3, i3 || [], h(e3).constructor) : t3.apply(e3, i3));
          }
          function a() {
            try {
              var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              }));
            } catch (e4) {
            }
            return (a = function() {
              return !!e3;
            })();
          }
          function h(e3) {
            return h = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
              return e4.__proto__ || Object.getPrototypeOf(e4);
            }, h(e3);
          }
          function c(e3, t3) {
            return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
              return e4.__proto__ = t4, e4;
            }, c(e3, t3);
          }
          var l = function() {
            function e3(t4, n3) {
              var r2;
              return function(e4, t5) {
                if (!(e4 instanceof t5)) throw new TypeError("Cannot call a class as a function");
              }(this, e3), (r2 = o(this, e3, [t4, n3]))._Raycaster = i2(232).t, r2;
            }
            return function(e4, t4) {
              if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
              e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && c(e4, t4);
            }(e3, Phaser.Plugins.ScenePlugin), t3 = e3, n2 = [{ key: "createRaycaster", value: function() {
              var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
              return e4.scene = this.scene, new this._Raycaster(e4);
            } }], n2 && r(t3.prototype, n2), s2 && r(t3, s2), Object.defineProperty(t3, "prototype", { writable: false }), t3;
            var t3, n2, s2;
          }();
          e2.exports = l;
        }, 998: function(e2, t2, i2) {
          "use strict";
          function n() {
            return this.object.getBounds();
          }
          i2.r(t2), i2.d(t2, { getBoundingBox: function() {
            return n;
          } });
        }, 197: function(e2, t2, i2) {
          "use strict";
          i2.d(t2, { $: function() {
            return g;
          } });
          var n = i2(502), r = i2(919), s = i2(645), o = i2(821), a = i2(620), h = i2(265), c = i2(216), l = i2(458), u = i2(998);
          function g(e3) {
            switch (this.object = e3.object, void 0 === e3.type && (e3.type = e3.object.type), "body" !== e3.type && "composite" !== e3.type || (e3.type = "MatterBody"), this.type = e3.type, e3.type) {
              case "Polygon":
                this.getPoints = s.getPoints, this.getSegments = s.getSegments, this.getBoundingBox = u.getBoundingBox, this.updateMap = s.updateMap;
                break;
              case "Arc":
                this.segmentCount = e3.segmentCount ? e3.segmentCount : 0, this.circle = !e3.segmentCount, this.getPoints = o.getPoints, this.getSegments = o.getSegments, this.getBoundingBox = u.getBoundingBox, this.updateMap = o.updateMap, this.setSegmentCount = l.setSegmentCount;
                break;
              case "Line":
                this.getPoints = r.getPoints, this.getSegments = r.getSegments, this.getBoundingBox = u.getBoundingBox, this.updateMap = r.updateMap;
                break;
              case "Container":
                this.mapChild = e3.mapChild ? e3.mapChild : null, this.segmentCount = e3.segmentCount ? e3.segmentCount : 0, this._circles = [], this.getPoints = a.getPoints, this.getSegments = a.getSegments, this.getBoundingBox = u.getBoundingBox, this.updateMap = a.updateMap, this._updateChildMap = a._updateChildMap, this.setSegmentCount = l.setSegmentCount;
                break;
              case "StaticTilemapLayer":
              case "DynamicTilemapLayer":
              case "TilemapLayer":
                this.collisionTiles = e3.collisionTiles ? e3.collisionTiles : [], this.getPoints = h.getPoints, this.getSegments = h.getSegments, this.getBoundingBox = u.getBoundingBox, this.updateMap = h.updateMap, this.setCollisionTiles = h.setCollisionTiles, this.object.setOrigin(0, 0);
                break;
              case "MatterBody":
                this.forceConvex = !!e3.forceConvex, this.forceVerticesMapping = !!e3.forceVerticesMapping, this.circle = false, this.getPoints = c.getPoints, this.getSegments = c.getSegments, this.getBoundingBox = c.getBoundingBox, this.updateMap = c.updateMap;
                break;
              default:
                this.getPoints = n.getPoints, this.getSegments = n.getSegments, this.getBoundingBox = u.getBoundingBox, this.updateMap = n.updateMap;
            }
            return "MatterBody" != this.type && "function" != typeof this.object.getBounds && (this.notSupported = true), this.dynamic = 1 == e3.dynamic, this.active = void 0 === e3.active || e3.active, this;
          }
        }, 385: function(e2, t2, i2) {
          "use strict";
          function n() {
            for (var e3 in "body" === this.object.type || "composite" === this.object.type ? delete this.object.raycasterMap : this.object.data && this.object.data.remove("raycasterMap"), this) delete this[e3];
          }
          i2.d(t2, { z: function() {
            return n;
          } });
        }, 821: function(e2, t2, i2) {
          "use strict";
          function n(e3, t3) {
            var i3 = "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
            if (!i3) {
              if (Array.isArray(e3) || (i3 = function(e4, t4) {
                if (e4) {
                  if ("string" == typeof e4) return r(e4, t4);
                  var i4 = {}.toString.call(e4).slice(8, -1);
                  return "Object" === i4 && e4.constructor && (i4 = e4.constructor.name), "Map" === i4 || "Set" === i4 ? Array.from(e4) : "Arguments" === i4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i4) ? r(e4, t4) : void 0;
                }
              }(e3)) || t3 && e3 && "number" == typeof e3.length) {
                i3 && (e3 = i3);
                var n2 = 0, s2 = function() {
                };
                return { s: s2, n: function() {
                  return n2 >= e3.length ? { done: true } : { done: false, value: e3[n2++] };
                }, e: function(e4) {
                  throw e4;
                }, f: s2 };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var o2, a2 = true, h = false;
            return { s: function() {
              i3 = i3.call(e3);
            }, n: function() {
              var e4 = i3.next();
              return a2 = e4.done, e4;
            }, e: function(e4) {
              h = true, o2 = e4;
            }, f: function() {
              try {
                a2 || null == i3.return || i3.return();
              } finally {
                if (h) throw o2;
              }
            } };
          }
          function r(e3, t3) {
            (null == t3 || t3 > e3.length) && (t3 = e3.length);
            for (var i3 = 0, n2 = Array(t3); i3 < t3; i3++) n2[i3] = e3[i3];
            return n2;
          }
          function s() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            if (!this.active) return [];
            if (this._points.length > 0) return this._points;
            var t3 = [], i3 = new Phaser.Geom.Point();
            if (i3.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5), i3.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5), e3) {
              var n2, r2 = new Phaser.Geom.Line(), s2 = new Phaser.Geom.Line(), o2 = this.object.rotation;
              if (0 !== o2) {
                var a2 = new Phaser.Geom.Line(this.object.x, this.object.y, i3.x, i3.y);
                Phaser.Geom.Line.SetToAngle(a2, this.object.x, this.object.y, Phaser.Geom.Line.Angle(a2) + o2, Phaser.Geom.Line.Length(a2));
                var h = a2.getPointB();
                n2 = new Phaser.Geom.Line(e3.origin.x, e3.origin.y, h.x, h.y);
              } else n2 = new Phaser.Geom.Line(e3.origin.x, e3.origin.y, i3.x, i3.y);
              var c = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(n2), 2) - Math.pow(this.object.radius * this.object.scaleX, 2)), l = Phaser.Geom.Line.Angle(n2), u = Math.asin(this.object.radius * this.object.scaleX / Phaser.Geom.Line.Length(n2));
              Phaser.Geom.Line.SetToAngle(r2, e3.origin.x, e3.origin.y, l - u, c), Phaser.Geom.Line.SetToAngle(s2, e3.origin.x, e3.origin.y, l + u, c), t3.push(r2.getPointB()), t3.push(s2.getPointB()), t3[0].neighbours = [t3[1]], t3[1].neighbours = [t3[0]];
            }
            return t3;
          }
          function o() {
            return this.active ? this._segments : [];
          }
          function a() {
            if (!this.active) return this;
            if (!this.segmentCount) return this._points = [], this._segments = [], this;
            var e3 = new Phaser.Geom.Point();
            e3.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX, e3.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;
            var t3 = this.object.geom.getPoints(this.segmentCount), i3 = [], r2 = this.object.rotation;
            if (0 !== r2) {
              var s2, o2 = [], a2 = n(t3);
              try {
                for (a2.s(); !(s2 = a2.n()).done; ) {
                  var h = s2.value, c = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (h.x + this.object.radius) * this.object.scaleX, this.object.y + (h.y + this.object.radius) * this.object.scaleY);
                  Phaser.Geom.Line.SetToAngle(c, this.object.x, this.object.y, Phaser.Geom.Line.Angle(c) + r2, Phaser.Geom.Line.Length(c)), o2.push(c.getPointB());
                }
              } catch (e4) {
                a2.e(e4);
              } finally {
                a2.f();
              }
              t3 = o2;
            } else {
              var l, u = n(t3);
              try {
                for (u.s(); !(l = u.n()).done; ) {
                  var g = l.value;
                  g.x = g.x * this.object.scaleX + e3.x, g.y = g.y * this.object.scaleY + e3.y;
                }
              } catch (e4) {
                u.e(e4);
              } finally {
                u.f();
              }
            }
            for (var y = 0, d = t3.length; y < d; y++) {
              var p = y > 0 ? t3[y - 1] : t3.slice(-1)[0], f = y < d - 1 ? t3[y + 1] : t3[0];
              i3.push(new Phaser.Geom.Line(t3[y].x, t3[y].y, f.x, f.y)), t3[y].neighbours = [p, f];
            }
            return this._points = t3, this._segments = i3, this;
          }
          i2.r(t2), i2.d(t2, { getPoints: function() {
            return s;
          }, getSegments: function() {
            return o;
          }, updateMap: function() {
            return a;
          } });
        }, 620: function(e2, t2, i2) {
          "use strict";
          function n(e3, t3) {
            var i3 = "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
            if (!i3) {
              if (Array.isArray(e3) || (i3 = function(e4, t4) {
                if (e4) {
                  if ("string" == typeof e4) return r(e4, t4);
                  var i4 = {}.toString.call(e4).slice(8, -1);
                  return "Object" === i4 && e4.constructor && (i4 = e4.constructor.name), "Map" === i4 || "Set" === i4 ? Array.from(e4) : "Arguments" === i4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i4) ? r(e4, t4) : void 0;
                }
              }(e3)) || t3 && e3 && "number" == typeof e3.length) {
                i3 && (e3 = i3);
                var n2 = 0, s2 = function() {
                };
                return { s: s2, n: function() {
                  return n2 >= e3.length ? { done: true } : { done: false, value: e3[n2++] };
                }, e: function(e4) {
                  throw e4;
                }, f: s2 };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var o2, a2 = true, h2 = false;
            return { s: function() {
              i3 = i3.call(e3);
            }, n: function() {
              var e4 = i3.next();
              return a2 = e4.done, e4;
            }, e: function(e4) {
              h2 = true, o2 = e4;
            }, f: function() {
              try {
                a2 || null == i3.return || i3.return();
              } finally {
                if (h2) throw o2;
              }
            } };
          }
          function r(e3, t3) {
            (null == t3 || t3 > e3.length) && (t3 = e3.length);
            for (var i3 = 0, n2 = Array(t3); i3 < t3; i3++) n2[i3] = e3[i3];
            return n2;
          }
          function s() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            if (!this.active) return [];
            var i3 = this._points, r2 = new Phaser.Geom.Point();
            if (r2.x = this.object.x - this.object.displayWidth * this.object.originX, r2.y = this.object.y - this.object.displayHeight * this.object.originY, 0 == this.segmentCount && !t3 && e3) {
              var s2 = new Phaser.Geom.Line(0, 0, e3.origin.x - r2.x, e3.origin.y - r2.y);
              Phaser.Geom.Line.SetToAngle(s2, 0, 0, Phaser.Geom.Line.Angle(s2) - this.object.rotation, Phaser.Geom.Line.Length(s2));
              var o2, a2, h2 = new Phaser.Geom.Line(), c = new Phaser.Geom.Line(), l = n(this._circles);
              try {
                for (l.s(); !(a2 = l.n()).done; ) {
                  var u = a2.value;
                  u.points = [], o2 = new Phaser.Geom.Line(e3.origin.x, e3.origin.y, u.x, u.y);
                  var g = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(o2), 2) - Math.pow(u.radius, 2)), y = Phaser.Geom.Line.Angle(o2), d = Math.asin(u.radius / Phaser.Geom.Line.Length(o2));
                  Phaser.Geom.Line.SetToAngle(h2, e3.origin.x, e3.origin.y, y - d, g), Phaser.Geom.Line.SetToAngle(c, e3.origin.x, e3.origin.y, y + d, g), u.points.push(h2.getPointB()), u.points.push(c.getPointB()), i3.push(h2.getPointB()), i3.push(c.getPointB());
                }
              } catch (e4) {
                l.e(e4);
              } finally {
                l.f();
              }
            }
            return i3;
          }
          function o() {
            return this.active ? this._segments : [];
          }
          function a() {
            if (!this.active) return this;
            var e3 = [], t3 = [], i3 = this.object;
            this._circles = [];
            var r2 = new Phaser.Geom.Point();
            r2.x = this.object.x - this.object.displayWidth * this.object.originX, r2.y = this.object.y - this.object.displayHeight * this.object.originY;
            var s2 = i3.rotation;
            if (this.mapChild) this._updateChildMap(this.mapChild, e3, t3, s2, r2);
            else {
              i3.iterate((function(i4) {
                this._updateChildMap(i4, e3, t3, s2, r2);
              }).bind(this));
              for (var o2 = 0, a2 = i3.list.length; o2 < a2; o2++) {
                var h2 = i3.list[o2], c = h2.data.get("raycasterMap");
                if (c) for (var l = o2 + 1, u = i3.list.length; l < u; l++) {
                  var g = i3.list[l], y = g.data.get("raycasterMap");
                  if (y && Phaser.Geom.Intersects.RectangleToRectangle(h2.getBounds(), g.getBounds())) {
                    var d, p = n(c.getSegments());
                    try {
                      for (p.s(); !(d = p.n()).done; ) {
                        var f, b = d.value, m = n(y.getSegments());
                        try {
                          for (m.s(); !(f = m.n()).done; ) {
                            var v = f.value, P = [];
                            if (Phaser.Geom.Intersects.LineToLine(b, v, P)) if (0 !== s2) {
                              var x = new Phaser.Geom.Line(i3.x, i3.y, P.x * i3.scaleX + r2.x, P.y * i3.scaleY + r2.y);
                              Phaser.Geom.Line.SetToAngle(x, this.object.x, this.object.y, Phaser.Geom.Line.Angle(x) + s2, Phaser.Geom.Line.Length(x)), e3.push(x.getPointB());
                            } else e3.push(new Phaser.Geom.Point(P.x * i3.scaleX + r2.x, P.y * i3.scaleX + r2.y));
                          }
                        } catch (e4) {
                          m.e(e4);
                        } finally {
                          m.f();
                        }
                      }
                    } catch (e4) {
                      p.e(e4);
                    } finally {
                      p.f();
                    }
                  }
                }
              }
            }
            return this._points = e3, this._segments = t3, this;
          }
          function h(e3, t3, i3, r2, s2) {
            if (e3.data || e3.setDataEnabled(), !e3.data.get("raycasterMapNotSupported")) {
              var o2 = e3.data.get("raycasterMap");
              if (o2) o2.updateMap();
              else {
                if ((o2 = new this.constructor({ object: e3, segmentCount: this.segmentCount })).notSupported) return o2.destroy(), void e3.data.set("raycasterMapNotSupported", true);
                e3.data.set("raycasterMap", o2);
              }
              var a2, h2 = [], c = n(o2.getPoints(false, true));
              try {
                for (c.s(); !(a2 = c.n()).done; ) {
                  var l = a2.value, u = void 0;
                  if (0 !== r2) {
                    var g = new Phaser.Geom.Line(this.object.x, this.object.y, l.x * this.object.scaleX + s2.x, l.y * this.object.scaleY + s2.y);
                    Phaser.Geom.Line.SetToAngle(g, this.object.x, this.object.y, Phaser.Geom.Line.Angle(g) + r2, Phaser.Geom.Line.Length(g)), u = g.getPointB();
                  } else u = new Phaser.Geom.Point(l.x * this.object.scaleX + s2.x, l.y * this.object.scaleX + s2.y);
                  if (u.neighbours = [], h2.length > 0) {
                    var y = h2.slice(-1)[0];
                    y.neighbours.push(u), u.neighbours.push(y);
                  }
                  h2.push(u), t3.push(u);
                }
              } catch (e4) {
                c.e(e4);
              } finally {
                c.f();
              }
              h2.length > 0 && h2.slice(-1)[0].neighbours.push(h2[0]);
              var d, p = n(o2.getSegments());
              try {
                for (p.s(); !(d = p.n()).done; ) {
                  var f = d.value;
                  if (0 !== r2) {
                    var b = f.getPointA(), m = f.getPointB(), v = new Phaser.Geom.Line(this.object.x, this.object.y, b.x * this.object.scaleX + s2.x, b.y * this.object.scaleY + s2.y), P = new Phaser.Geom.Line(this.object.x, this.object.y, m.x * this.object.scaleX + s2.x, m.y * this.object.scaleY + s2.y);
                    Phaser.Geom.Line.SetToAngle(v, this.object.x, this.object.y, Phaser.Geom.Line.Angle(v) + r2, Phaser.Geom.Line.Length(v)), Phaser.Geom.Line.SetToAngle(P, this.object.x, this.object.y, Phaser.Geom.Line.Angle(P) + r2, Phaser.Geom.Line.Length(P)), i3.push(new Phaser.Geom.Line(v.getPointB().x, v.getPointB().y, P.getPointB().x, P.getPointB().y));
                  } else i3.push(new Phaser.Geom.Line(f.getPointA().x * this.object.scaleX + s2.x, f.getPointA().y * this.object.scaleY + s2.y, f.getPointB().x * this.object.scaleX + s2.x, f.getPointB().y * this.object.scaleY + s2.y));
                }
              } catch (e4) {
                p.e(e4);
              } finally {
                p.f();
              }
              if ("Arc" == o2.type && 0 == this.segmentCount) {
                var x = new Phaser.Geom.Point();
                if (x.x = (o2.object.x - o2.object.displayWidth * (o2.object.originX - 0.5)) * this.object.scaleX + s2.x, x.y = (o2.object.y - o2.object.displayHeight * (o2.object.originY - 0.5)) * this.object.scaleY + s2.y, 0 !== r2) {
                  var j = new Phaser.Geom.Line(this.object.x, this.object.y, x.x, x.y);
                  Phaser.Geom.Line.SetToAngle(j, this.object.x, this.object.y, Phaser.Geom.Line.Angle(j) + r2, Phaser.Geom.Line.Length(j)), x = j.getPointB();
                }
                this._circles.push(new Phaser.Geom.Circle(x.x, x.y, o2.object.radius * o2.object.scaleX * this.object.scaleX));
              } else if ("Container" === o2.type) {
                var M, w = n(o2._circles);
                try {
                  for (w.s(); !(M = w.n()).done; ) {
                    var G = M.value, _ = new Phaser.Geom.Point();
                    if (_.x = G.x * this.object.scaleX + s2.x, _.y = G.y * this.object.scaleY + s2.y, 0 !== r2) {
                      var A = new Phaser.Geom.Line(this.object.x, this.object.y, _.x, _.y);
                      Phaser.Geom.Line.SetToAngle(A, this.object.x, this.object.y, Phaser.Geom.Line.Angle(A) + r2, Phaser.Geom.Line.Length(A)), _ = A.getPointB();
                    }
                    this._circles.push(new Phaser.Geom.Circle(_.x, _.y, G.radius * this.object.scaleX));
                  }
                } catch (e4) {
                  w.e(e4);
                } finally {
                  w.f();
                }
              }
            }
          }
          i2.r(t2), i2.d(t2, { _updateChildMap: function() {
            return h;
          }, getPoints: function() {
            return s;
          }, getSegments: function() {
            return o;
          }, updateMap: function() {
            return a;
          } });
        }, 465: function(e2, t2, i2) {
          "use strict";
          function n(e3, t3) {
            return this._raycaster = t3 || false, this.type, this.active, this._dynamic = false, this.circle = false, this.object, this._points = [], this._segments = [], this.getPoints, this.getSegments, this.getBoundingBox, this.updateMap, this.config(e3), this.notSupported || this.updateMap(), this;
          }
          i2.d(t2, { T: function() {
            return n;
          } }), n.prototype = { config: i2(197).$, destroy: i2(385).z, get dynamic() {
            return this._dynamic;
          }, set dynamic(e3) {
            if (this._dynamic == e3) return this;
            if (e3) this._dynamic = true, this._raycaster && (this._raycaster.dynamicMappedObjects.push(this.object), this._raycaster._stats.mappedObjects.dynamic = this._raycaster.dynamicMappedObjects.length, this._raycaster._stats.mappedObjects.static = this._raycaster._stats.mappedObjects.total - this._raycaster._stats.mappedObjects.dynamic);
            else if (this._dynamic = false, this._raycaster) {
              var t3 = this._raycaster.dynamicMappedObjects.indexOf(this.object);
              t3 >= 0 && this._raycaster.dynamicMappedObjects.splice(t3, 1), this._raycaster._stats.mappedObjects.dynamic = this._raycaster.dynamicMappedObjects.length, this._raycaster._stats.mappedObjects.static = this._raycaster._stats.mappedObjects.total - this._raycaster._stats.mappedObjects.dynamic;
            }
            return this;
          } }, n.prototype.constructor = n;
        }, 919: function(e2, t2, i2) {
          "use strict";
          function n() {
            return this.active ? this._points : [];
          }
          function r() {
            return this.active ? this._segments : [];
          }
          function s() {
            if (!this.active) return this;
            var e3 = [], t3 = [], i3 = new Phaser.Geom.Point();
            i3.x = this.object.x - this.object.displayWidth * this.object.originX, i3.y = this.object.y - this.object.displayHeight * this.object.originY;
            var n2 = this.object.geom.getPointA(), r2 = this.object.geom.getPointB(), s2 = this.object.rotation;
            if (0 !== s2) {
              var o = new Phaser.Geom.Line(this.object.x, this.object.y, n2.x * this.object.scaleX + i3.x, n2.y * this.object.scaleY + i3.y);
              Phaser.Geom.Line.SetToAngle(o, this.object.x, this.object.y, Phaser.Geom.Line.Angle(o) + s2, Phaser.Geom.Line.Length(o)), n2 = o.getPointB();
              var a = new Phaser.Geom.Line(this.object.x, this.object.y, r2.x * this.object.scaleX + i3.x, r2.y * this.object.scaleY + i3.y);
              Phaser.Geom.Line.SetToAngle(a, this.object.x, this.object.y, Phaser.Geom.Line.Angle(a) + s2, Phaser.Geom.Line.Length(a)), r2 = a.getPointB(), e3.push(new Phaser.Geom.Point(n2.x, n2.y)), e3.push(new Phaser.Geom.Point(r2.x, r2.y)), t3.push(new Phaser.Geom.Line(n2.x, n2.y, r2.x, r2.y));
            } else e3.push(new Phaser.Geom.Point(n2.x * this.object.scaleX + i3.x, n2.y * this.object.scaleY + i3.y)), e3.push(new Phaser.Geom.Point(r2.x * this.object.scaleX + i3.x, r2.y * this.object.scaleY + i3.y)), t3.push(new Phaser.Geom.Line(n2.x * this.object.scaleX + i3.x, n2.y * this.object.scaleY + i3.y, r2.x + i3.x * this.object.scaleX, r2.y * this.object.scaleY + i3.y));
            return e3[0].neighbours = [e3[1]], e3[1].neighbours = [e3[0]], this._points = e3, this._segments = t3, this;
          }
          i2.r(t2), i2.d(t2, { getPoints: function() {
            return n;
          }, getSegments: function() {
            return r;
          }, updateMap: function() {
            return s;
          } });
        }, 216: function(e2, t2, i2) {
          "use strict";
          function n(e3, t3) {
            var i3 = "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
            if (!i3) {
              if (Array.isArray(e3) || (i3 = function(e4, t4) {
                if (e4) {
                  if ("string" == typeof e4) return r(e4, t4);
                  var i4 = {}.toString.call(e4).slice(8, -1);
                  return "Object" === i4 && e4.constructor && (i4 = e4.constructor.name), "Map" === i4 || "Set" === i4 ? Array.from(e4) : "Arguments" === i4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i4) ? r(e4, t4) : void 0;
                }
              }(e3)) || t3 && e3 && "number" == typeof e3.length) {
                i3 && (e3 = i3);
                var n2 = 0, s2 = function() {
                };
                return { s: s2, n: function() {
                  return n2 >= e3.length ? { done: true } : { done: false, value: e3[n2++] };
                }, e: function(e4) {
                  throw e4;
                }, f: s2 };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var o2, a2 = true, h2 = false;
            return { s: function() {
              i3 = i3.call(e3);
            }, n: function() {
              var e4 = i3.next();
              return a2 = e4.done, e4;
            }, e: function(e4) {
              h2 = true, o2 = e4;
            }, f: function() {
              try {
                a2 || null == i3.return || i3.return();
              } finally {
                if (h2) throw o2;
              }
            } };
          }
          function r(e3, t3) {
            (null == t3 || t3 > e3.length) && (t3 = e3.length);
            for (var i3 = 0, n2 = Array(t3); i3 < t3; i3++) n2[i3] = e3[i3];
            return n2;
          }
          function s() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            if (!this.active) return [];
            var t3 = "body" === this.object.type || "composite" === this.object.type ? this.object : this.object.body;
            if (e3 && !this.forceVerticesMapping && t3.circleRadius > 0) {
              var i3 = [], n2 = new Phaser.Geom.Line(), r2 = new Phaser.Geom.Line(), s2 = new Phaser.Geom.Line(e3.origin.x, e3.origin.y, t3.position.x, t3.position.y), o2 = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(s2), 2) - Math.pow(t3.circleRadius * t3.scale.x, 2)), a2 = Phaser.Geom.Line.Angle(s2), h2 = Math.asin(t3.circleRadius * t3.scale.x / Phaser.Geom.Line.Length(s2));
              return Phaser.Geom.Line.SetToAngle(n2, e3.origin.x, e3.origin.y, a2 - h2, o2), Phaser.Geom.Line.SetToAngle(r2, e3.origin.x, e3.origin.y, a2 + h2, o2), i3.push(n2.getPointB(), r2.getPointB()), i3;
            }
            return this._points;
          }
          function o() {
            return this.active ? this._segments : [];
          }
          function a() {
            if (!this.active) return this;
            var e3 = [], t3 = [], i3 = "body" === this.object.type || "composite" === this.object.type ? this.object : this.object.body, r2 = [i3], s2 = false;
            if (i3.circleRadius > 0 && !this.forceVerticesMapping) return this.circle = true, this._points = e3, this._segments = t3, this;
            this.circle = false, "composite" == i3.type && (r2 = i3.bodies), (void 0 === i3.bounds && "composite" == i3.type || "composite" == i3.type && this.dynamic) && (s2 = true);
            var o2, a2 = n(r2);
            try {
              for (a2.s(); !(o2 = a2.n()).done; ) {
                var h2 = o2.value;
                if (1 === h2.parts.length || this.forceConvex) {
                  var c = h2.parts[0].vertices;
                  e3.push(new Phaser.Geom.Point(c[0].x, c[0].y)), e3[0].neighbours = [];
                  for (var l = 1, u = c.length; l < u; l++) {
                    var g = e3.slice(-1)[0], y = new Phaser.Geom.Point(c[l].x, c[l].y);
                    g.neighbours || (g.neighbours = []), g.neighbours.push(y), y.neighbours = [g], e3.push(y);
                    var d = new Phaser.Geom.Line(g.x, g.y, y.x, y.y);
                    t3.push(d);
                  }
                  var p = new Phaser.Geom.Line(c[c.length - 1].x, c[c.length - 1].y, c[0].x, c[0].y);
                  t3.push(p), e3[0].neighbours.push(e3.slice(-1)[0]);
                } else {
                  for (var f = [], b = [], m = 1, v = h2.parts.length; m < v; m++) {
                    for (var P = h2.parts[m].vertices, x = [], j = 0, M = P.length; j < M; j++) {
                      var w = new Phaser.Geom.Point(P[j].x, P[j].y);
                      if (x.length) {
                        var G = x.slice(-1)[0];
                        w.neighbours = [G], G.neighbours.push(w);
                      } else w.neighbours = [];
                      var _ = P[j].x + "/" + P[j].y;
                      void 0 === b[_] ? (e3.push(w), b[_] = w) : (b[_].neighbours.push(w), w.neighbours.push(b[_])), x.push(w), P[j].isInternal && (f.push(x), x = []);
                    }
                    f.push(x);
                  }
                  for (var A = 0, S = f; A < S.length; A++) {
                    var B, L = S[A], O = 0;
                    for (O = 0, B = L.length - 1; O < B; O++) t3.push(new Phaser.Geom.Line(L[O].x, L[O].y, L[O + 1].x, L[O + 1].y));
                  }
                }
              }
            } catch (e4) {
              a2.e(e4);
            } finally {
              a2.f();
            }
            if (this._points = e3, this._segments = t3, s2) {
              var T = this._raycaster.scene.matter.composite.bounds(i3);
              i3.bounds = T;
            }
            return this;
          }
          function h() {
            var e3 = "body" === this.object.type || "composite" === this.object.type ? this.object.bounds : this.object.body.bounds;
            return new Phaser.Geom.Rectangle(e3.min.x, e3.min.y, e3.max.x - e3.min.x, e3.max.y - e3.min.y);
          }
          i2.r(t2), i2.d(t2, { getBoundingBox: function() {
            return h;
          }, getPoints: function() {
            return s;
          }, getSegments: function() {
            return o;
          }, updateMap: function() {
            return a;
          } });
        }, 645: function(e2, t2, i2) {
          "use strict";
          function n(e3, t3) {
            var i3 = "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
            if (!i3) {
              if (Array.isArray(e3) || (i3 = function(e4, t4) {
                if (e4) {
                  if ("string" == typeof e4) return r(e4, t4);
                  var i4 = {}.toString.call(e4).slice(8, -1);
                  return "Object" === i4 && e4.constructor && (i4 = e4.constructor.name), "Map" === i4 || "Set" === i4 ? Array.from(e4) : "Arguments" === i4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i4) ? r(e4, t4) : void 0;
                }
              }(e3)) || t3 && e3 && "number" == typeof e3.length) {
                i3 && (e3 = i3);
                var n2 = 0, s2 = function() {
                };
                return { s: s2, n: function() {
                  return n2 >= e3.length ? { done: true } : { done: false, value: e3[n2++] };
                }, e: function(e4) {
                  throw e4;
                }, f: s2 };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var o2, a2 = true, h = false;
            return { s: function() {
              i3 = i3.call(e3);
            }, n: function() {
              var e4 = i3.next();
              return a2 = e4.done, e4;
            }, e: function(e4) {
              h = true, o2 = e4;
            }, f: function() {
              try {
                a2 || null == i3.return || i3.return();
              } finally {
                if (h) throw o2;
              }
            } };
          }
          function r(e3, t3) {
            (null == t3 || t3 > e3.length) && (t3 = e3.length);
            for (var i3 = 0, n2 = Array(t3); i3 < t3; i3++) n2[i3] = e3[i3];
            return n2;
          }
          function s() {
            return this.active ? this._points : [];
          }
          function o() {
            return this.active ? this._segments : [];
          }
          function a() {
            if (!this.active) return this;
            var e3 = [], t3 = [], i3 = new Phaser.Geom.Point();
            i3.x = this.object.x - this.object.displayWidth * this.object.originX, i3.y = this.object.y - this.object.displayHeight * this.object.originY;
            var r2 = this.object.rotation;
            if (0 !== r2) {
              var s2, o2 = n(this.object.geom.points);
              try {
                for (o2.s(); !(s2 = o2.n()).done; ) {
                  var a2 = s2.value, h = new Phaser.Geom.Line(this.object.x, this.object.y, a2.x * this.object.scaleX + i3.x, a2.y * this.object.scaleY + i3.y);
                  Phaser.Geom.Line.SetToAngle(h, this.object.x, this.object.y, Phaser.Geom.Line.Angle(h) + r2, Phaser.Geom.Line.Length(h)), e3.push(h.getPointB());
                }
              } catch (e4) {
                o2.e(e4);
              } finally {
                o2.f();
              }
            } else {
              var c, l = n(this.object.geom.points);
              try {
                for (l.s(); !(c = l.n()).done; ) {
                  var u = c.value;
                  e3.push(new Phaser.Geom.Point(u.x * this.object.scaleX + i3.x, u.y * this.object.scaleY + i3.y));
                }
              } catch (e4) {
                l.e(e4);
              } finally {
                l.f();
              }
            }
            for (var g = 0, y = e3.length; g < y; g++) {
              var d = g > 0 ? e3[g - 1] : e3.slice(-1)[0], p = g < y - 1 ? e3[g + 1] : e3[0];
              t3.push(new Phaser.Geom.Line(e3[g].x, e3[g].y, p.x, p.y)), e3[g].neighbours = [d, p];
            }
            for (var f = 0, b = e3.length; f < b; f++) f + 1 < b && t3.push(new Phaser.Geom.Line(e3[f].x, e3[f].y, e3[f + 1].x, e3[f + 1].y));
            return this.object.closePath || (t3.pop(), e3[0].neighbours.shift(), e3[e3.length - 1].neighbours.pop()), this._points = e3, this._segments = t3, this;
          }
          i2.r(t2), i2.d(t2, { getPoints: function() {
            return s;
          }, getSegments: function() {
            return o;
          }, updateMap: function() {
            return a;
          } });
        }, 502: function(e2, t2, i2) {
          "use strict";
          function n() {
            return this.active ? this._points : [];
          }
          function r() {
            return this.active ? this._segments : [];
          }
          function s() {
            if (!this.active) return this;
            for (var e3 = [], t3 = [], i3 = 0, n2 = (e3 = [this.object.getTopLeft(), this.object.getTopRight(), this.object.getBottomRight(), this.object.getBottomLeft()]).length; i3 < n2; i3++) {
              var r2 = i3 > 0 ? e3[i3 - 1] : e3.slice(-1)[0], s2 = i3 < n2 - 1 ? e3[i3 + 1] : e3[0];
              t3.push(new Phaser.Geom.Line(e3[i3].x, e3[i3].y, s2.x, s2.y)), e3[i3].neighbours = [r2, s2];
            }
            return this._points = e3, this._segments = t3, this;
          }
          i2.r(t2), i2.d(t2, { getPoints: function() {
            return n;
          }, getSegments: function() {
            return r;
          }, updateMap: function() {
            return s;
          } });
        }, 265: function(e2, t2, i2) {
          "use strict";
          function n(e3, t3) {
            var i3 = "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
            if (!i3) {
              if (Array.isArray(e3) || (i3 = function(e4, t4) {
                if (e4) {
                  if ("string" == typeof e4) return r(e4, t4);
                  var i4 = {}.toString.call(e4).slice(8, -1);
                  return "Object" === i4 && e4.constructor && (i4 = e4.constructor.name), "Map" === i4 || "Set" === i4 ? Array.from(e4) : "Arguments" === i4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i4) ? r(e4, t4) : void 0;
                }
              }(e3)) || t3 && e3 && "number" == typeof e3.length) {
                i3 && (e3 = i3);
                var n2 = 0, s2 = function() {
                };
                return { s: s2, n: function() {
                  return n2 >= e3.length ? { done: true } : { done: false, value: e3[n2++] };
                }, e: function(e4) {
                  throw e4;
                }, f: s2 };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var o2, a2 = true, h2 = false;
            return { s: function() {
              i3 = i3.call(e3);
            }, n: function() {
              var e4 = i3.next();
              return a2 = e4.done, e4;
            }, e: function(e4) {
              h2 = true, o2 = e4;
            }, f: function() {
              try {
                a2 || null == i3.return || i3.return();
              } finally {
                if (h2) throw o2;
              }
            } };
          }
          function r(e3, t3) {
            (null == t3 || t3 > e3.length) && (t3 = e3.length);
            for (var i3 = 0, n2 = Array(t3); i3 < t3; i3++) n2[i3] = e3[i3];
            return n2;
          }
          function s() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            if (!this.active) return [];
            if (!e3 || e3 && (0 == e3.detectionRange || e3.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER)) return this._points;
            var t3, i3 = [], r2 = n(this._points);
            try {
              for (r2.s(); !(t3 = r2.n()).done; ) {
                var s2 = t3.value;
                Phaser.Math.Distance.Between(e3.origin.x, e3.origin.y, s2.x, s2.y) <= e3.detectionRange && i3.push(s2);
              }
            } catch (e4) {
              r2.e(e4);
            } finally {
              r2.f();
            }
            var o2, a2 = n(this.getSegments(e3));
            try {
              for (a2.s(); !(o2 = a2.n()).done; ) {
                var h2 = o2.value;
                Phaser.Math.Distance.Between(e3.origin.x, e3.origin.y, h2.x1, h2.y1) > e3.detectionRange && i3.push(new Phaser.Geom.Point(h2.x1, h2.y1)), Phaser.Math.Distance.Between(e3.origin.x, e3.origin.y, h2.x2, h2.y2) > e3.detectionRange && i3.push(new Phaser.Geom.Point(h2.x2, h2.y2));
              }
            } catch (e4) {
              a2.e(e4);
            } finally {
              a2.f();
            }
            return i3;
          }
          function o() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            if (!this.active) return [];
            if (!e3 || e3 && (0 == e3.detectionRange || e3.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER)) return this._segments;
            var t3, i3 = [], r2 = n(this._segments);
            try {
              for (r2.s(); !(t3 = r2.n()).done; ) {
                var s2 = t3.value;
                Phaser.Geom.Intersects.LineToCircle(s2, e3.detectionRangeCircle) && i3.push(s2);
              }
            } catch (e4) {
              r2.e(e4);
            } finally {
              r2.f();
            }
            return i3;
          }
          function a() {
            if (!this.active) return this;
            for (var e3 = [], t3 = [], i3 = Array(this.object.layer.data[0].length + 1), n2 = 0, r2 = i3.length; n2 < r2; n2++) i3[n2] = [];
            var s2, o2, a2 = new Phaser.Geom.Point(this.object.x, this.object.y), h2 = this.object.layer.data[0], c = this.object.layer.tileWidth * this.object.scaleX, l = this.object.layer.tileHeight * this.object.scaleY;
            this.collisionTiles.includes(h2[0].index) && (s2 = new Phaser.Geom.Point(a2.x, a2.y), o2 = new Phaser.Geom.Point(c + a2.x, a2.y), i3[0].push(s2));
            for (var u = 1, g = h2.length; u < g; u++) {
              var y = h2[u];
              if (this.collisionTiles.includes(y.index)) {
                var d = u * c + a2.x, p = a2.y;
                s2 || (s2 = new Phaser.Geom.Point(d, p), i3[u].push(s2)), o2 ? o2.x = d + c : o2 = new Phaser.Geom.Point(d + c, p);
              } else s2 && (s2.neighbours = [o2], o2.neighbours = [s2], e3.push(s2, o2), t3.push(new Phaser.Geom.Line(s2.x, s2.y, o2.x, o2.y)), i3[u].push(o2), s2 = false, o2 = false);
            }
            s2 && (s2.neighbours = [o2], o2.neighbours = [s2], e3.push(s2, o2), t3.push(new Phaser.Geom.Line(s2.x, s2.y, o2.x, o2.y)), i3[h2.length].push(o2)), s2 = false, o2 = false;
            for (var f = 1, b = this.object.layer.data.length; f < b; f++) {
              h2 = this.object.layer.data[f];
              var m = this.object.layer.data[f - 1];
              this.collisionTiles.includes(h2[0].index) != this.collisionTiles.includes(m[0].index) && (s2 = new Phaser.Geom.Point(a2.x, f * l + a2.y), o2 = new Phaser.Geom.Point(c + a2.x, f * l + a2.y), i3[0].push(s2));
              for (var v = 1, P = h2.length; v < P; v++) {
                var x = h2[v];
                if (this.collisionTiles.includes(x.index) != this.collisionTiles.includes(m[v].index)) {
                  var j = v * c + a2.x, M = f * l + a2.y;
                  s2 || (s2 = new Phaser.Geom.Point(j, M), i3[v].push(s2)), o2 ? o2.x = j + c : o2 = new Phaser.Geom.Point(j + c, M);
                } else s2 && (s2.neighbours = [o2], o2.neighbours = [s2], e3.push(s2, o2), t3.push(new Phaser.Geom.Line(s2.x, s2.y, o2.x, o2.y)), i3[v].push(o2), s2 = false, o2 = false);
              }
              s2 && (s2.neighbours = [o2], o2.neighbours = [s2], e3.push(s2, o2), t3.push(new Phaser.Geom.Line(s2.x, s2.y, o2.x, o2.y)), i3[h2.length].push(o2)), s2 = false, o2 = false;
            }
            h2 = this.object.layer.data.slice(-1)[0];
            var w = this.object.layer.data.length * l + a2.y;
            this.collisionTiles.includes(h2[0].index) && (s2 = new Phaser.Geom.Point(a2.x, w), o2 = new Phaser.Geom.Point(c + a2.x, w), i3[0].push(s2));
            for (var G = 1, _ = h2.length; G < _; G++) {
              var A = h2[G];
              if (this.collisionTiles.includes(A.index)) {
                var S = G * c + a2.x;
                s2 || (s2 = new Phaser.Geom.Point(S, w), i3[G].push(s2)), o2 ? o2.x = S + c : o2 = new Phaser.Geom.Point(S + c, w);
              } else s2 && (s2.neighbours = [o2], o2.neighbours = [s2], e3.push(s2, o2), t3.push(new Phaser.Geom.Line(s2.x, s2.y, o2.x, o2.y)), i3[G].push(o2), s2 = false, o2 = false);
            }
            s2 && (s2.neighbours = [o2], o2.neighbours = [s2], e3.push(s2, o2), t3.push(new Phaser.Geom.Line(s2.x, s2.y, o2.x, o2.y)), i3[h2.length].push(o2));
            for (var B = 0, L = i3.length; B < L; B++) for (var O = i3[B], T = 0, C = O.length - 1; T < C; T++) t3.push(new Phaser.Geom.Line(O[T].x, O[T].y, O[T + 1].x, O[T + 1].y)), O[T].neighbours.push(O[T + 1]), O[T + 1].neighbours.push(O[T]), T++;
            return this._points = e3, this._segments = t3, this;
          }
          function h() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
            return this.collisionTiles = e3, this;
          }
          i2.r(t2), i2.d(t2, { getPoints: function() {
            return s;
          }, getSegments: function() {
            return o;
          }, setCollisionTiles: function() {
            return h;
          }, updateMap: function() {
            return a;
          } });
        }, 458: function(e2, t2, i2) {
          "use strict";
          function n(e3) {
            return this.segmentCount = e3, this.circle = !e3, this.updateMap(), this;
          }
          i2.r(t2), i2.d(t2, { setSegmentCount: function() {
            return n;
          } });
        }, 822: function(e2, t2, i2) {
          "use strict";
          function n() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            return this.angle = Phaser.Math.Angle.Normalize(e3), Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange), this;
          }
          function r() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            return this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(e3)), Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange), this;
          }
          i2.d(t2, { O: function() {
            return r;
          }, S: function() {
            return n;
          } });
        }, 974: function(e2, t2, i2) {
          "use strict";
          function n(e3, t3) {
            var i3 = "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
            if (!i3) {
              if (Array.isArray(e3) || (i3 = function(e4, t4) {
                if (e4) {
                  if ("string" == typeof e4) return r(e4, t4);
                  var i4 = {}.toString.call(e4).slice(8, -1);
                  return "Object" === i4 && e4.constructor && (i4 = e4.constructor.name), "Map" === i4 || "Set" === i4 ? Array.from(e4) : "Arguments" === i4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i4) ? r(e4, t4) : void 0;
                }
              }(e3)) || t3 && e3 && "number" == typeof e3.length) {
                i3 && (e3 = i3);
                var n2 = 0, s2 = function() {
                };
                return { s: s2, n: function() {
                  return n2 >= e3.length ? { done: true } : { done: false, value: e3[n2++] };
                }, e: function(e4) {
                  throw e4;
                }, f: s2 };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var o, a = true, h = false;
            return { s: function() {
              i3 = i3.call(e3);
            }, n: function() {
              var e4 = i3.next();
              return a = e4.done, e4;
            }, e: function(e4) {
              h = true, o = e4;
            }, f: function() {
              try {
                a || null == i3.return || i3.return();
              } finally {
                if (h) throw o;
              }
            } };
          }
          function r(e3, t3) {
            (null == t3 || t3 > e3.length) && (t3 = e3.length);
            for (var i3 = 0, n2 = Array(t3); i3 < t3; i3++) n2[i3] = e3[i3];
            return n2;
          }
          function s() {
            var e3, t3, i3, r2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, s2 = this.rayRange, o = !!r2.internal && r2.internal, a = performance.now(), h = { method: "cast", rays: 1, testedMappedObjects: 0, hitMappedObjects: 0, segments: 0, time: 0 };
            if (this._raycaster && this._raycaster.boundingBox) {
              var c = [];
              if (Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, c), 1 === c.length) e3 = c[0];
              else if (c.length > 1) {
                var l, u = n(c);
                try {
                  for (u.s(); !(l = u.n()).done; ) {
                    var g = l.value, y = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, g.x, g.y);
                    y < s2 && (s2 = y, e3 = g);
                  }
                } catch (e4) {
                  u.e(e4);
                } finally {
                  u.f();
                }
              } else if (r2.target) {
                var d = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, r2.target.x, r2.target.y);
                this.rayRange > d && (s2 = d, e3 = r2.target);
              }
            }
            if (!r2.objects) {
              if (!this._raycaster) return intersections;
              r2.objects = this._raycaster.mappedObjects;
            }
            var p, f, b = n(r2.objects);
            try {
              for (b.s(); !(p = b.n()).done; ) {
                var m = p.value, v = void 0, P = void 0, x = [], j = false;
                if (v = "body" === m.type || "composite" === m.type ? m.raycasterMap : m.data.get("raycasterMap"), h.testedMappedObjects++, o ? P = v._boundingBox : (P = v.getBoundingBox()).setTo(P.x - 0.1, P.y - 0.1, P.width + 0.2, P.height + 0.2), 0 !== Phaser.Geom.Intersects.GetLineToRectangle(this._ray, P, x).length) {
                  if (Phaser.Geom.Rectangle.ContainsPoint(P, this.origin)) j = true;
                  else {
                    var M, w = n(x);
                    try {
                      for (w.s(); !(M = w.n()).done; ) {
                        var G = M.value;
                        if (Phaser.Math.Distance.Between(this.origin.x, this.origin.y, G.x, G.y) < s2) {
                          j = true;
                          break;
                        }
                      }
                    } catch (e4) {
                      w.e(e4);
                    } finally {
                      w.f();
                    }
                  }
                  if (j) {
                    h.hitMappedObjects++, h.segments += v.getSegments(this).length;
                    var _, A = n(v.getSegments(this));
                    try {
                      for (A.s(); !(_ = A.n()).done; ) {
                        var S = _.value, B = [];
                        if (r2.target) {
                          if (Phaser.Geom.Point.Equals(r2.target, S.getPointA()) || Phaser.Geom.Point.Equals(r2.target, S.getPointB())) B = r2.target;
                          else if (!Phaser.Geom.Intersects.LineToLine(this._ray, S, B)) continue;
                        } else if (!Phaser.Geom.Intersects.LineToLine(this._ray, S, B)) continue;
                        var L = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, B.x, B.y);
                        L < s2 && (s2 = L, e3 = B, i3 = v.object, t3 = S);
                      }
                    } catch (e4) {
                      A.e(e4);
                    } finally {
                      A.f();
                    }
                    if (v.circle) {
                      if (v._points.length > 0) continue;
                      if (r2.target) {
                        var O, T = v.getPoints(this), C = false, R = n(T);
                        try {
                          for (R.s(); !(O = R.n()).done; ) {
                            var I = O.value;
                            if (Phaser.Geom.Point.Equals(r2.target, I)) {
                              var E = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, I.x, I.y);
                              if (E < s2) {
                                s2 = E, e3 = I, i3 = v.object, C = true;
                                break;
                              }
                            }
                          }
                        } catch (e4) {
                          R.e(e4);
                        } finally {
                          R.f();
                        }
                        if (C) continue;
                      }
                      var D = [], X = new Phaser.Geom.Point();
                      X.x = v.object.x - v.object.displayWidth * (v.object.originX - 0.5), X.y = v.object.y - v.object.displayHeight * (v.object.originY - 0.5);
                      var k = v.object.rotation;
                      if (0 !== k) {
                        var Y = new Phaser.Geom.Line(v.object.x, v.object.y, X.x, X.y);
                        Phaser.Geom.Line.SetToAngle(Y, v.object.x, v.object.y, Phaser.Geom.Line.Angle(Y) + k, Phaser.Geom.Line.Length(Y));
                        var N = Y.getPointB();
                        X.x = N.x, X.y = N.y;
                      }
                      var W = new Phaser.Geom.Circle(X.x, X.y, v.object.radius * v.object.scaleX);
                      if (Phaser.Geom.Intersects.GetLineToCircle(this._ray, W, D)) {
                        var z, $ = n(D);
                        try {
                          for ($.s(); !(z = $.n()).done; ) {
                            var q = z.value, F = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, q.x, q.y);
                            F < s2 && (s2 = F, e3 = q, i3 = v.object);
                          }
                        } catch (e4) {
                          $.e(e4);
                        } finally {
                          $.f();
                        }
                      }
                    }
                    if ("Container" == v.type && v._circles.length > 0) {
                      var U, H = n(v._circles);
                      try {
                        for (H.s(); !(U = H.n()).done; ) {
                          var V = U.value;
                          if (r2.target) {
                            var Z, J = false, K = n(V.points);
                            try {
                              for (K.s(); !(Z = K.n()).done; ) {
                                var Q = Z.value;
                                if (Phaser.Geom.Point.Equals(r2.target, Q)) {
                                  var ee = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, Q.x, Q.y);
                                  if (ee < s2) {
                                    s2 = ee, e3 = Q, i3 = v.object, J = true;
                                    break;
                                  }
                                }
                              }
                            } catch (e4) {
                              K.e(e4);
                            } finally {
                              K.f();
                            }
                            if (J) continue;
                          }
                          var te = [];
                          if (Phaser.Geom.Intersects.GetLineToCircle(this._ray, V, te)) {
                            var ie, ne = n(te);
                            try {
                              for (ne.s(); !(ie = ne.n()).done; ) {
                                var re = ie.value, se = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, re.x, re.y);
                                se < s2 && (s2 = se, e3 = re, i3 = v.object);
                              }
                            } catch (e4) {
                              ne.e(e4);
                            } finally {
                              ne.f();
                            }
                          }
                        }
                      } catch (e4) {
                        H.e(e4);
                      } finally {
                        H.f();
                      }
                    }
                  }
                }
              }
            } catch (e4) {
              b.e(e4);
            } finally {
              b.f();
            }
            if (o ? (this._stats.rays++, this._stats.testedMappedObjects += h.testedMappedObjects, this._stats.hitMappedObjects += h.hitMappedObjects, this._stats.segments += h.segments) : (h.time = performance.now() - a, this._stats = h), e3) (f = new Phaser.Geom.Point(e3.x, e3.y)).segment = t3, f.object = i3;
            else {
              if (this.ignoreNotIntersectedRays) return false;
              f = this._ray.getPointB();
            }
            return this.round && (f.x = Math.round(f.x), f.y = Math.round(f.y)), o || this.drawDebug([f]), f;
          }
          i2.d(t2, { w: function() {
            return s;
          } });
        }, 506: function(e2, t2, i2) {
          "use strict";
          function n(e3, t3) {
            var i3 = "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
            if (!i3) {
              if (Array.isArray(e3) || (i3 = function(e4, t4) {
                if (e4) {
                  if ("string" == typeof e4) return r(e4, t4);
                  var i4 = {}.toString.call(e4).slice(8, -1);
                  return "Object" === i4 && e4.constructor && (i4 = e4.constructor.name), "Map" === i4 || "Set" === i4 ? Array.from(e4) : "Arguments" === i4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i4) ? r(e4, t4) : void 0;
                }
              }(e3)) || t3 && e3 && "number" == typeof e3.length) {
                i3 && (e3 = i3);
                var n2 = 0, s2 = function() {
                };
                return { s: s2, n: function() {
                  return n2 >= e3.length ? { done: true } : { done: false, value: e3[n2++] };
                }, e: function(e4) {
                  throw e4;
                }, f: s2 };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var o, a = true, h = false;
            return { s: function() {
              i3 = i3.call(e3);
            }, n: function() {
              var e4 = i3.next();
              return a = e4.done, e4;
            }, e: function(e4) {
              h = true, o = e4;
            }, f: function() {
              try {
                a || null == i3.return || i3.return();
              } finally {
                if (h) throw o;
              }
            } };
          }
          function r(e3, t3) {
            (null == t3 || t3 > e3.length) && (t3 = e3.length);
            for (var i3 = 0, n2 = Array(t3); i3 < t3; i3++) n2[i3] = e3[i3];
            return n2;
          }
          function s() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = this.angle, i3 = [], r2 = [], s2 = [], o = [], a = performance.now();
            if (this._stats = { method: "castCircle", rays: 0, testedMappedObjects: 0, hitMappedObjects: 0, segments: 0, time: 0 }, !e3.objects) {
              if (!this._raycaster) return i3;
              e3.objects = this._raycaster.mappedObjects;
            }
            if (this._raycaster && this._raycaster.boundingBox) {
              var h, c = n(this._raycaster.boundingBox.points);
              try {
                for (c.s(); !(h = c.n()).done; ) {
                  var l = h.value;
                  s2.push({ point: l, angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, l.x, l.y) });
                }
              } catch (e4) {
                c.e(e4);
              } finally {
                c.f();
              }
            }
            for (var u = 0, g = e3.objects.length; u < g; u++) {
              var y = e3.objects[u];
              if (this.boundsInRange(y)) {
                o.push(y);
                var d = void 0, p = void 0;
                (p = (d = "body" === y.type || "composite" === y.type ? y.raycasterMap : y.data.get("raycasterMap")).getBoundingBox()).setTo(p.x - 0.1, p.y - 0.1, p.width + 0.2, p.height + 0.2), d._boundingBox = p, r2.push(d);
                var f, b = n(d.getPoints(this));
                try {
                  for (b.s(); !(f = b.n()).done; ) {
                    var m = f.value;
                    s2.push({ point: m, angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, m.x, m.y) });
                  }
                } catch (e4) {
                  b.e(e4);
                } finally {
                  b.f();
                }
                for (var v = u + 1, P = e3.objects.length; v < P; v++) {
                  var x = e3.objects[v], j = void 0;
                  if (j = "body" === x.type || "composite" === x.type ? x.raycasterMap : x.data.get("raycasterMap"), Phaser.Geom.Intersects.RectangleToRectangle(d.getBoundingBox(), j.getBoundingBox())) {
                    var M, w = n(d.getSegments(this));
                    try {
                      for (w.s(); !(M = w.n()).done; ) {
                        var G, _ = M.value, A = n(j.getSegments(this));
                        try {
                          for (A.s(); !(G = A.n()).done; ) {
                            var S = G.value, B = [];
                            if (Phaser.Geom.Intersects.LineToLine(_, S, B)) {
                              var L = { point: new Phaser.Geom.Point(B.x, B.y), angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, B.x, B.y) };
                              L.point.intersection = false, s2.push(L);
                            }
                          }
                        } catch (e4) {
                          A.e(e4);
                        } finally {
                          A.f();
                        }
                      }
                    } catch (e4) {
                      w.e(e4);
                    } finally {
                      w.f();
                    }
                  }
                }
              }
            }
            s2.sort((function(e4, t4) {
              return e4.angle == t4.angle ? Phaser.Math.Distance.Between(this.origin.x, this.origin.y, e4.point.x, e4.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, t4.point.x, t4.point.y) ? 1 : -1 : e4.angle - t4.angle;
            }).bind(this));
            for (var O = { angle: false }, T = 0, C = s2; T < C.length; T++) {
              var R = C[T];
              if (R.angle !== O.angle) {
                O = R, this.setAngle(R.angle);
                var I = this.cast({ objects: o, target: R.point, internal: true });
                if (I) {
                  var E = false;
                  if (this.round) {
                    var D = new Phaser.Geom.Point(Math.round(R.point.x), Math.round(R.point.y));
                    E = Phaser.Geom.Point.Equals(D, I);
                  } else E = Phaser.Geom.Point.Equals(R.point, I);
                  if (E) if (!R.point.neighbours || R.point.neighbours.length < 2) ;
                  else if (Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, R.point.neighbours[0])) < 1e-4 || Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, R.point.neighbours[1])) < 1e-4) ;
                  else {
                    var X = [];
                    R.point.neighboursTriangle || (R.point.neighboursTriangle = new Phaser.Geom.Triangle(R.point.x, R.point.y, R.point.neighbours[0].x, R.point.neighbours[0].y, R.point.neighbours[1].x, R.point.neighbours[1].y)), Phaser.Geom.Intersects.GetTriangleToLine(R.point.neighboursTriangle, this._ray, X);
                    for (var k = 0, Y = X; k < Y.length; k++) {
                      var N = Y[k];
                      if (Math.abs(R.point.x - N.x) > 1e-4 && Math.abs(R.point.y - N.y) > 1e-4) {
                        E = false;
                        break;
                      }
                    }
                  }
                  else ;
                  if (E) {
                    this.setAngle(R.angle - 1e-4);
                    var W = this.cast({ objects: o, internal: true });
                    W && i3.push(W), i3.push(I), this.setAngle(R.angle + 1e-4);
                    var z = this.cast({ objects: o, internal: true });
                    z && i3.push(z);
                    continue;
                  }
                  i3.push(I);
                }
              }
            }
            return this.setAngle(t3), this.intersections = i3, this.autoSlice && (this.slicedIntersections = this.slice()), this._stats.time = performance.now() - a, this.drawDebug(i3), i3;
          }
          i2.d(t2, { I: function() {
            return s;
          } });
        }, 757: function(e2, t2, i2) {
          "use strict";
          function n(e3, t3) {
            var i3 = "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
            if (!i3) {
              if (Array.isArray(e3) || (i3 = function(e4, t4) {
                if (e4) {
                  if ("string" == typeof e4) return r(e4, t4);
                  var i4 = {}.toString.call(e4).slice(8, -1);
                  return "Object" === i4 && e4.constructor && (i4 = e4.constructor.name), "Map" === i4 || "Set" === i4 ? Array.from(e4) : "Arguments" === i4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i4) ? r(e4, t4) : void 0;
                }
              }(e3)) || t3 && e3 && "number" == typeof e3.length) {
                i3 && (e3 = i3);
                var n2 = 0, s2 = function() {
                };
                return { s: s2, n: function() {
                  return n2 >= e3.length ? { done: true } : { done: false, value: e3[n2++] };
                }, e: function(e4) {
                  throw e4;
                }, f: s2 };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var o, a = true, h = false;
            return { s: function() {
              i3 = i3.call(e3);
            }, n: function() {
              var e4 = i3.next();
              return a = e4.done, e4;
            }, e: function(e4) {
              h = true, o = e4;
            }, f: function() {
              try {
                a || null == i3.return || i3.return();
              } finally {
                if (h) throw o;
              }
            } };
          }
          function r(e3, t3) {
            (null == t3 || t3 > e3.length) && (t3 = e3.length);
            for (var i3 = 0, n2 = Array(t3); i3 < t3; i3++) n2[i3] = e3[i3];
            return n2;
          }
          function s() {
            var e3, t3, i3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r2 = this.angle, s2 = [], o = [], a = [], h = [], c = this.cone, l = performance.now();
            if (this._stats = { method: "castCone", rays: 0, testedMappedObjects: 0, hitMappedObjects: 0, segments: 0, time: 0 }, void 0 !== i3.cone && (c = i3.cone), void 0 !== i3.coneDeg && (c = Phaser.Math.DegToRad(i3.coneDeg)), e3 = this.angle - c / 2, t3 = this.angle + c / 2, this.setAngle(e3), a.push({ point: this._ray.getPointB(), angle: e3, angleOffsetDeg: Phaser.Math.RadToDeg(-c / 2) }), this.setAngle(t3), a.push({ point: this._ray.getPointB(), angle: t3, angleOffsetDeg: Phaser.Math.RadToDeg(c / 2) }), !i3.objects) {
              if (!this._raycaster) return s2;
              i3.objects = this._raycaster.mappedObjects;
            }
            if (this._raycaster && this._raycaster.boundingBox) {
              var u, g = n(this._raycaster.boundingBox.points);
              try {
                for (g.s(); !(u = g.n()).done; ) {
                  var y = u.value, d = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, y.x, y.y), p = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(d), Phaser.Math.RadToDeg(r2));
                  Math.abs(p) < Phaser.Math.RadToDeg(c / 2) && a.push({ point: y, angle: d, angleOffsetDeg: -p });
                }
              } catch (e4) {
                g.e(e4);
              } finally {
                g.f();
              }
            }
            for (var f = 0, b = i3.objects.length; f < b; f++) {
              var m = i3.objects[f];
              if (this.boundsInRange(m)) {
                h.push(m);
                var v = void 0, P = void 0;
                (P = (v = "body" === m.type || "composite" === m.type ? m.raycasterMap : m.data.get("raycasterMap")).getBoundingBox()).setTo(P.x - 0.1, P.y - 0.1, P.width + 0.2, P.height + 0.2), v._boundingBox = P, o.push(v);
                var x, j = n(v.getPoints(this));
                try {
                  for (j.s(); !(x = j.n()).done; ) {
                    var M = x.value, w = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, M.x, M.y), G = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(w), Phaser.Math.RadToDeg(r2));
                    Math.abs(G) < Phaser.Math.RadToDeg(c / 2) && a.push({ point: M, angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, M.x, M.y), angleOffsetDeg: -G });
                  }
                } catch (e4) {
                  j.e(e4);
                } finally {
                  j.f();
                }
                for (var _ = f + 1, A = i3.objects.length; _ < A; _++) {
                  var S = i3.objects[_], B = void 0;
                  if (B = "body" === S.type || "composite" === S.type ? S.raycasterMap : S.data.get("raycasterMap"), Phaser.Geom.Intersects.RectangleToRectangle(v.getBoundingBox(), B.getBoundingBox())) {
                    var L, O = n(v.getSegments(this));
                    try {
                      for (O.s(); !(L = O.n()).done; ) {
                        var T, C = L.value, R = n(B.getSegments(this));
                        try {
                          for (R.s(); !(T = R.n()).done; ) {
                            var I = T.value, E = [];
                            if (Phaser.Geom.Intersects.LineToLine(C, I, E)) {
                              var D = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, E.x, E.y), X = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(D), Phaser.Math.RadToDeg(r2));
                              Math.abs(X) < Phaser.Math.RadToDeg(c / 2) && a.push({ point: new Phaser.Geom.Point(E.x, E.y), angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, E.x, E.y), angleOffsetDeg: -X });
                            }
                          }
                        } catch (e4) {
                          R.e(e4);
                        } finally {
                          R.f();
                        }
                      }
                    } catch (e4) {
                      O.e(e4);
                    } finally {
                      O.f();
                    }
                  }
                }
              }
            }
            a.sort((function(e4, t4) {
              return e4.angle == t4.angle ? Phaser.Math.Distance.Between(this.origin.x, this.origin.y, e4.point.x, e4.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, t4.point.x, t4.point.y) ? 1 : -1 : e4.angleOffsetDeg - t4.angleOffsetDeg;
            }).bind(this));
            for (var k = { angle: false }, Y = 0, N = a; Y < N.length; Y++) {
              var W = N[Y];
              if (W.angle !== k.angle) {
                k = W, this.setAngle(W.angle);
                var z = this.cast({ objects: h, target: W.point, internal: true });
                if (z) {
                  var $ = false;
                  if (this.round) {
                    var q = new Phaser.Geom.Point(Math.round(W.point.x), Math.round(W.point.y));
                    $ = Phaser.Geom.Point.Equals(q, z);
                  } else $ = Phaser.Geom.Point.Equals(W.point, z);
                  if ($) if (!W.point.neighbours || W.point.neighbours.length < 2) ;
                  else if (Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, W.point.neighbours[0])) < 1e-4 || Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, W.point.neighbours[1])) < 1e-4) ;
                  else {
                    var F = [];
                    W.point.neighboursTriangle || (W.point.neighboursTriangle = new Phaser.Geom.Triangle(W.point.x, W.point.y, W.point.neighbours[0].x, W.point.neighbours[0].y, W.point.neighbours[1].x, W.point.neighbours[1].y)), Phaser.Geom.Intersects.GetTriangleToLine(W.point.neighboursTriangle, this._ray, F);
                    for (var U = 0, H = F; U < H.length; U++) {
                      var V = H[U];
                      if (Math.abs(W.point.x - V.x) > 1e-4 && Math.abs(W.point.y - V.y) > 1e-4) {
                        $ = false;
                        break;
                      }
                    }
                  }
                  else ;
                  if ($) {
                    this.setAngle(W.angle - 1e-4);
                    var Z = this.cast({ objects: h, internal: true });
                    Z && s2.push(Z), s2.push(z), this.setAngle(W.angle + 1e-4);
                    var J = this.cast({ objects: h, internal: true });
                    J && s2.push(J);
                    continue;
                  }
                  s2.push(z);
                }
              }
            }
            return this.setAngle(r2), this.intersections = s2, this.autoSlice && (this.slicedIntersections = this.slice(s2, false)), this._stats.time = performance.now() - l, this.drawDebug(s2), s2;
          }
          i2.d(t2, { d: function() {
            return s;
          } });
        }, 582: function(e2, t2, i2) {
          "use strict";
          function n() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            return this.cone = e3, this;
          }
          function r() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            return this.cone = Phaser.Math.DegToRad(e3), this;
          }
          i2.d(t2, { M: function() {
            return n;
          }, U: function() {
            return r;
          } });
        }, 807: function(e2, t2, i2) {
          "use strict";
          function n(e3) {
            return this.object = e3.object, void 0 !== e3.origin && this.origin.setTo(e3.origin.x, e3.origin.y), void 0 !== e3.angle && (this.angle = Phaser.Math.Angle.Normalize(e3.angle)), void 0 !== e3.angleDeg && (this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(e3.angleDeg))), void 0 !== e3.cone && (this.cone = e3.cone), void 0 !== e3.coneDeg && (this.cone = Phaser.Math.DegToRad(e3.coneDeg)), void 0 !== e3.rayRange && (this.rayRange = e3.rayRange), void 0 !== e3.collisionRange && (this.collisionRange = e3.collisionRange), void 0 !== e3.detectionRange && (this.detectionRange = e3.detectionRange), void 0 !== e3.ignoreNotIntersectedRays && (this.ignoreNotIntersectedRays = 1 == e3.ignoreNotIntersectedRays), void 0 !== e3.round && (this.round = 1 == e3.round), void 0 !== e3.autoSlice && (this.autoSlice = 1 == e3.autoSlice), void 0 !== e3.enablePhysics && e3.enablePhysics && this.enablePhysics(e3.enablePhysics), Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange), this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange), this._raycaster.debugOptions.enabled && void 0 !== this._raycaster.scene && (this.graphics = this._raycaster.scene.add.graphics({ lineStyle: { width: 1, color: 65280 }, fillStyle: { color: 16711935 } }), this.graphics.setDepth(1e3)), this;
          }
          i2.d(t2, { $: function() {
            return n;
          } });
        }, 882: function(e2, t2, i2) {
          "use strict";
          function n(e3, t3) {
            var i3 = "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
            if (!i3) {
              if (Array.isArray(e3) || (i3 = function(e4, t4) {
                if (e4) {
                  if ("string" == typeof e4) return r(e4, t4);
                  var i4 = {}.toString.call(e4).slice(8, -1);
                  return "Object" === i4 && e4.constructor && (i4 = e4.constructor.name), "Map" === i4 || "Set" === i4 ? Array.from(e4) : "Arguments" === i4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i4) ? r(e4, t4) : void 0;
                }
              }(e3)) || t3 && e3 && "number" == typeof e3.length) {
                i3 && (e3 = i3);
                var n2 = 0, s2 = function() {
                };
                return { s: s2, n: function() {
                  return n2 >= e3.length ? { done: true } : { done: false, value: e3[n2++] };
                }, e: function(e4) {
                  throw e4;
                }, f: s2 };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var o, a = true, h = false;
            return { s: function() {
              i3 = i3.call(e3);
            }, n: function() {
              var e4 = i3.next();
              return a = e4.done, e4;
            }, e: function(e4) {
              h = true, o = e4;
            }, f: function() {
              try {
                a || null == i3.return || i3.return();
              } finally {
                if (h) throw o;
              }
            } };
          }
          function r(e3, t3) {
            (null == t3 || t3 > e3.length) && (t3 = e3.length);
            for (var i3 = 0, n2 = Array(t3); i3 < t3; i3++) n2[i3] = e3[i3];
            return n2;
          }
          function s(e3) {
            if (void 0 === this.graphics || !this._raycaster.debugOptions.enabled) return this;
            if (this.graphics.clear(), !this._raycaster.debugOptions.rays) return this;
            if (this._raycaster.debugOptions.graphics.ray) {
              this.graphics.lineStyle(1, this._raycaster.debugOptions.graphics.ray);
              var t3, i3 = n(e3);
              try {
                for (i3.s(); !(t3 = i3.n()).done; ) {
                  var r2 = t3.value;
                  this.graphics.strokeLineShape({ x1: this.origin.x, y1: this.origin.y, x2: r2.x, y2: r2.y });
                }
              } catch (e4) {
                i3.e(e4);
              } finally {
                i3.f();
              }
            }
            if (this._raycaster.debugOptions.graphics.rayPoint) {
              this.graphics.fillStyle(this._raycaster.debugOptions.graphics.rayPoint), this.graphics.fillPoint(this.origin.x, this.origin.y, 3);
              var s2, o = n(e3);
              try {
                for (o.s(); !(s2 = o.n()).done; ) {
                  var a = s2.value;
                  this.graphics.fillPoint(a.x, a.y, 3);
                }
              } catch (e4) {
                o.e(e4);
              } finally {
                o.f();
              }
            }
            return this;
          }
          i2.d(t2, { s: function() {
            return s;
          } });
        }, 487: function(e2, t2, i2) {
          "use strict";
          function n() {
            for (var e3 in this.graphics && this.graphics.destroy(), this) delete this[e3];
          }
          i2.d(t2, { z: function() {
            return n;
          } });
        }, 181: function(e2, t2, i2) {
          "use strict";
          function n() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "arcade";
            if (void 0 !== this.body) return this;
            if (this.collisionCircle = this._raycaster.scene.add.circle(this.origin.x, this.origin.y, this.collisionRange), this.collisionCircle._ray = this, "matter" === e3) {
              if (this.bodyType = "matter", this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {
                var t3 = this._raycaster.boundingBox;
                this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: "rectangle", x: t3.rectangle.centerX, y: t3.rectangle.centerY, width: t3.rectangle.width, height: t3.rectangle.height }, label: "phaser-raycaster-ray-body", isSensor: true, ignoreGravity: true });
              } else this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: "circle" }, label: "phaser-raycaster-ray-body", isSensor: true, ignoreGravity: true });
              this.body = this.collisionCircle.body, this.body._ray = this, this.setOnCollideActive();
            } else this.bodyType = "arcade", this._raycaster.scene.physics.add.existing(this.collisionCircle), this.body = this.collisionCircle.body, this.body.setCircle(this.collisionRange).setAllowGravity(false).setImmovable(true), this.body._ray = this;
            return this;
          }
          i2.d(t2, { z: function() {
            return n;
          } });
        }, 127: function(e2, t2, i2) {
          "use strict";
          function n(e3) {
            return this.body.collisionFilter.category = e3, this;
          }
          function r(e3) {
            return this.body.collisionFilter.group = e3, this;
          }
          function s(e3) {
            var t3 = 0;
            if (Array.isArray(e3)) for (var i3 = 0; i3 < e3.length; i3++) t3 |= e3[i3];
            else t3 = e3;
            return this.body.collisionFilter.mask = t3, this;
          }
          function o(e3) {
            var t3 = this;
            return this.body.onCollideCallback = function(i3) {
              i3.rayCollided ? e3(i3) : t3.processOverlap(i3) && (i3.rayCollided = true, e3(i3));
            }, this;
          }
          function a(e3) {
            return this.body.onCollideEndCallback = function(t3) {
              t3.rayCollided && (t3.rayCollided = false, e3(t3));
            }, this;
          }
          function h(e3) {
            var t3 = this;
            return this.body.onCollideActiveCallback = function(i3) {
              if (t3.processOverlap(i3)) {
                var n2 = "phaser-raycaster-ray-body" === i3.bodyA.label ? i3.bodyB : i3.bodyA;
                true !== i3.rayCollided && (i3.rayCollided = true, t3.body.onCollideCallback && t3.body.onCollideCallback(i3), void 0 !== t3.body.onCollideWith && t3.body.onCollideWith[n2.id] && t3.body.onCollideWith[n2.id](n2, i3)), e3 && e3(i3);
              } else t3.body.onCollideEndCallback && true === i3.rayCollided && t3.body.onCollideEndCallback(i3);
            }, this;
          }
          function c(e3, t3) {
            var i3 = this, n2 = function(e4, n3) {
              n3.rayCollided ? t3(e4, n3) : i3.processOverlap(n3) && (n3.rayCollided = true, t3(e4, n3));
            };
            Array.isArray(e3) || (e3 = [e3]);
            for (var r2 = 0; r2 < e3.length; r2++) {
              var s2 = e3[r2].hasOwnProperty("body") ? e3[r2].body : e3[r2];
              this.body.setOnCollideWith(s2, n2);
            }
            return this;
          }
          i2.d(t2, { C$: function() {
            return h;
          }, Ih: function() {
            return s;
          }, iI: function() {
            return r;
          }, iu: function() {
            return c;
          }, op: function() {
            return o;
          }, xG: function() {
            return a;
          }, zh: function() {
            return n;
          } });
        }, 551: function(e2, t2, i2) {
          "use strict";
          function n(e3, t3) {
            return this.origin.setTo(e3, t3), Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange), this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange), ("matter" === this.bodyType && this.collisionRange !== Phaser.Math.MAX_SAFE_INTEGER || "arcade" === this.bodyType) && (this.collisionCircle.x = e3, this.collisionCircle.y = t3), this;
          }
          i2.d(t2, { v: function() {
            return n;
          } });
        }, 698: function(e2, t2, i2) {
          "use strict";
          function n(e3, t3) {
            var i3 = "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
            if (!i3) {
              if (Array.isArray(e3) || (i3 = function(e4, t4) {
                if (e4) {
                  if ("string" == typeof e4) return r(e4, t4);
                  var i4 = {}.toString.call(e4).slice(8, -1);
                  return "Object" === i4 && e4.constructor && (i4 = e4.constructor.name), "Map" === i4 || "Set" === i4 ? Array.from(e4) : "Arguments" === i4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i4) ? r(e4, t4) : void 0;
                }
              }(e3)) || t3 && e3 && "number" == typeof e3.length) {
                i3 && (e3 = i3);
                var n2 = 0, s2 = function() {
                };
                return { s: s2, n: function() {
                  return n2 >= e3.length ? { done: true } : { done: false, value: e3[n2++] };
                }, e: function(e4) {
                  throw e4;
                }, f: s2 };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var o2, a2 = true, h2 = false;
            return { s: function() {
              i3 = i3.call(e3);
            }, n: function() {
              var e4 = i3.next();
              return a2 = e4.done, e4;
            }, e: function(e4) {
              h2 = true, o2 = e4;
            }, f: function() {
              try {
                a2 || null == i3.return || i3.return();
              } finally {
                if (h2) throw o2;
              }
            } };
          }
          function r(e3, t3) {
            (null == t3 || t3 > e3.length) && (t3 = e3.length);
            for (var i3 = 0, n2 = Array(t3); i3 < t3; i3++) n2[i3] = e3[i3];
            return n2;
          }
          function s(e3) {
            var t3 = [], i3 = new Phaser.Geom.Circle(this.origin.x, this.origin.y, this.collisionRange);
            if ("matter" === this.bodyType) {
              if (void 0 === e3) {
                var r2, s2 = n(e3 = this._raycaster.scene.matter.query.collides(this.body, this._raycaster.scene.matter.getMatterBodies()));
                try {
                  for (s2.s(); !(r2 = s2.n()).done; ) {
                    var o2 = r2.value, a2 = o2.bodyA === this.body ? o2.bodyB : o2.bodyA;
                    this.testMatterOverlap(a2) && t3.push(a2);
                  }
                } catch (e4) {
                  s2.e(e4);
                } finally {
                  s2.f();
                }
              } else {
                Array.isArray(e3) || (e3 = [e3]);
                var h2, c = n(e3);
                try {
                  for (c.s(); !(h2 = c.n()).done; ) {
                    var l = h2.value;
                    l !== this.body && (this.testMatterOverlap(l) && t3.push(l));
                  }
                } catch (e4) {
                  c.e(e4);
                } finally {
                  c.f();
                }
              }
            } else {
              var u = false;
              if (void 0 === e3 ? (e3 = this._raycaster.scene.physics.overlapCirc(this.origin.x, this.origin.y, this.collisionRange, true, true), u = true) : Array.isArray(e3) || (e3 = [e3]), u) {
                var g, y = n(e3);
                try {
                  for (y.s(); !(g = y.n()).done; ) {
                    var d = g.value;
                    if (d !== this.body) {
                      var p = void 0;
                      p = d.isCircle ? new Phaser.Geom.Circle(d.position.x + d.halfWidth, d.position.y + d.halfWidth, d.halfWidth) : new Phaser.Geom.Rectangle(d.x, d.y, d.width, d.height), this.testArcadeOverlap(p) && t3.push(d.gameObject);
                    }
                  }
                } catch (e4) {
                  y.e(e4);
                } finally {
                  y.f();
                }
              } else {
                var f, b = n(e3);
                try {
                  for (b.s(); !(f = b.n()).done; ) {
                    var m = f.value;
                    if (void 0 !== m.body) {
                      var v = void 0;
                      if (m.body.isCircle) {
                        if (v = new Phaser.Geom.Circle(m.body.position.x + m.body.halfWidth, m.body.position.y + m.body.halfWidth, m.body.halfWidth), !Phaser.Geom.Intersects.CircleToCircle(i3, v)) continue;
                      } else if (v = new Phaser.Geom.Rectangle(m.body.x, m.body.y, m.body.width, m.body.height), !Phaser.Geom.Intersects.CircleToRectangle(i3, v)) continue;
                      this.testArcadeOverlap(v) && t3.push(m);
                    }
                  }
                } catch (e4) {
                  b.e(e4);
                } finally {
                  b.f();
                }
              }
            }
            return t3;
          }
          function o(e3, t3) {
            var i3, n2, r2;
            if (void 0 !== e3.bodyA && void 0 !== e3.bodyB ? (i3 = e3.bodyA, n2 = e3.bodyB) : (i3 = e3, n2 = t3), void 0 !== i3._ray && i3._ray === this) r2 = n2;
            else {
              if (void 0 === n2._ray || n2._ray !== this) return false;
              r2 = i3;
            }
            return this.overlap(r2).length > 0;
          }
          function a(e3) {
            var t3, i3 = n(this.slicedIntersections);
            try {
              for (i3.s(); !(t3 = i3.n()).done; ) {
                var r2 = t3.value;
                if (0 == e3.type ? Phaser.Geom.Intersects.TriangleToCircle(r2, e3) : Phaser.Geom.Intersects.RectangleToTriangle(e3, r2)) return true;
              }
            } catch (e4) {
              i3.e(e4);
            } finally {
              i3.f();
            }
            return false;
          }
          function h(e3) {
            var t3;
            if ("body" === e3.type) t3 = e3;
            else {
              if (void 0 === e3.body) return false;
              t3 = e3.body;
            }
            var i3, r2 = n(t3.parts.length > 1 ? t3.parts.splice(1) : t3.parts);
            try {
              for (r2.s(); !(i3 = r2.n()).done; ) {
                for (var s2 = i3.value, o2 = s2.vertices[0], a2 = 1, h2 = s2.vertices.length; a2 < h2; a2++) {
                  var c, l = s2.vertices[a2], u = new Phaser.Geom.Line(o2.x, o2.y, l.x, l.y), g = n(this.slicedIntersections);
                  try {
                    for (g.s(); !(c = g.n()).done; ) {
                      var y = c.value, d = Phaser.Geom.Intersects.TriangleToLine(y, u);
                      if (d || (d = Phaser.Geom.Triangle.ContainsPoint(y, u.getPointA())), d || (d = Phaser.Geom.Triangle.ContainsPoint(y, u.getPointB())), d) return true;
                    }
                  } catch (e4) {
                    g.e(e4);
                  } finally {
                    g.f();
                  }
                  o2 = l;
                }
                var p, f = new Phaser.Geom.Line(s2.vertices[s2.vertices.length - 1].x, s2.vertices[s2.vertices.length - 1].y, s2.vertices[0].x, s2.vertices[0].y), b = n(this.slicedIntersections);
                try {
                  for (b.s(); !(p = b.n()).done; ) {
                    var m = p.value;
                    if (Phaser.Geom.Intersects.TriangleToLine(m, f)) return true;
                  }
                } catch (e4) {
                  b.e(e4);
                } finally {
                  b.f();
                }
              }
            } catch (e4) {
              r2.e(e4);
            } finally {
              r2.f();
            }
            return false;
          }
          i2.d(t2, { EF: function() {
            return s;
          }, ZI: function() {
            return o;
          }, a_: function() {
            return a;
          }, nY: function() {
            return h;
          } });
        }, 760: function(e2, t2, i2) {
          "use strict";
          function n() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Phaser.Math.MAX_SAFE_INTEGER;
            return this.rayRange = e3, Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange), this;
          }
          function r() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            return this.detectionRange = e3, this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange), this;
          }
          function s() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Phaser.Math.MAX_SAFE_INTEGER, t3 = this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER;
            if (this.collisionRange = e3, this.collisionCircle.setRadius(this.collisionRange), "matter" === this.bodyType) {
              if (this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {
                var i3 = this._raycaster.boundingBox;
                this._raycaster.scene.matter.body.set(this.body, { shape: { type: "rectangle", x: i3.rectangle.centerX, y: i3.rectangle.centerY, width: i3.rectangle.width, height: i3.rectangle.height, circleRadius: 0 } });
              } else t3 ? this._raycaster.scene.matter.body.set(this.body, { shape: { type: "circle", x: this.collisionCircle.x, y: this.collisionCircle.y }, circleRadius: this.collisionRange, isStatic: false }) : this.collisionCircle.setRadius(this.collisionRange);
              this._raycaster.scene.matter.body.set(this.body, "circleRadius", this.collisionRange);
            } else "arcade" === this.bodyType && this.body.setCircle(this.collisionRange);
            return this;
          }
          function o(e3) {
            var t3, i3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            return !this.detectionRange || (t3 = i3 || ("body" === e3.type || "composite" === e3.type ? e3.raycasterMap.getBoundingBox() : e3.data.get("raycasterMap").getBoundingBox()), !!Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, t3));
          }
          i2.d(t2, { Bl: function() {
            return r;
          }, eq: function() {
            return o;
          }, o0: function() {
            return s;
          }, qL: function() {
            return n;
          } });
        }, 689: function(e2, t2, i2) {
          "use strict";
          function n(e3, t3) {
            this._raycaster = t3 || false, this.origin = new Phaser.Geom.Point(), this._ray = new Phaser.Geom.Line(), this.angle = 0, this.cone = 0, this.rayRange = Phaser.Math.MAX_SAFE_INTEGER, this.detectionRange = 0, this.detectionRangeCircle = new Phaser.Geom.Circle(), this.collisionRange = Phaser.Math.MAX_SAFE_INTEGER, this.ignoreNotIntersectedRays = true, this.round = false, this.autoSlice = false, this.intersections = [], this.slicedIntersections = [], this.bodyType = false, this._stats = { method: "cast", rays: 0, testedMappedObjects: 0, hitMappedObjects: 0, segments: 0, time: 0 }, this.graphics, this.config(e3);
          }
          i2.d(t2, { R: function() {
            return n;
          } }), n.prototype = { config: i2(807).$, getStats: i2(838).G, setRay: i2(26).n, setOrigin: i2(551).v, setRayRange: i2(760).qL, setAngle: i2(822).S, setAngleDeg: i2(822).O, setCone: i2(582).M, setConeDeg: i2(582).U, setDetectionRange: i2(760).Bl, boundsInRange: i2(760).eq, cast: i2(974).w, castCircle: i2(506).I, castCone: i2(757).d, slice: i2(691).d, setCollisionRange: i2(760).o0, enablePhysics: i2(181).z, overlap: i2(698).EF, processOverlap: i2(698).ZI, testArcadeOverlap: i2(698).a_, testMatterOverlap: i2(698).nY, setCollisionCategory: i2(127).zh, setCollisionGroup: i2(127).iI, setCollidesWith: i2(127).Ih, setOnCollide: i2(127).op, setOnCollideEnd: i2(127).xG, setOnCollideActive: i2(127).C$, setOnCollideWith: i2(127).iu, drawDebug: i2(882).s, destroy: i2(487).z };
        }, 26: function(e2, t2, i2) {
          "use strict";
          function n(e3, t3, i3) {
            var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Phaser.Math.MAX_SAFE_INTEGER;
            return this.origin.setTo(e3, t3), this.angle = Phaser.Math.Angle.Normalize(i3), this.rayRange = n2, Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange), this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange), this;
          }
          i2.d(t2, { n: function() {
            return n;
          } });
        }, 691: function(e2, t2, i2) {
          "use strict";
          function n() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.intersections, t3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if (!Array.isArray(e3)) {
              if (4 !== e3.type) return [];
              e3 = e3.points;
            }
            if (0 === e3.length) return [];
            for (var i3 = [], n2 = 0, r = e3.length - 1; n2 < r; n2++) i3.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, e3[n2].x, e3[n2].y, e3[n2 + 1].x, e3[n2 + 1].y));
            return t3 && i3.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, e3[0].x, e3[0].y, e3[e3.length - 1].x, e3[e3.length - 1].y)), i3;
          }
          i2.d(t2, { d: function() {
            return n;
          } });
        }, 838: function(e2, t2, i2) {
          "use strict";
          function n() {
            return this._stats;
          }
          i2.d(t2, { G: function() {
            return n;
          } });
        }, 232: function(e2, t2, i2) {
          "use strict";
          function n(e3, t3) {
            var i3 = "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
            if (!i3) {
              if (Array.isArray(e3) || (i3 = function(e4, t4) {
                if (e4) {
                  if ("string" == typeof e4) return r(e4, t4);
                  var i4 = {}.toString.call(e4).slice(8, -1);
                  return "Object" === i4 && e4.constructor && (i4 = e4.constructor.name), "Map" === i4 || "Set" === i4 ? Array.from(e4) : "Arguments" === i4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i4) ? r(e4, t4) : void 0;
                }
              }(e3)) || t3 && e3 && "number" == typeof e3.length) {
                i3 && (e3 = i3);
                var n2 = 0, s2 = function() {
                };
                return { s: s2, n: function() {
                  return n2 >= e3.length ? { done: true } : { done: false, value: e3[n2++] };
                }, e: function(e4) {
                  throw e4;
                }, f: s2 };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var o2, a = true, h = false;
            return { s: function() {
              i3 = i3.call(e3);
            }, n: function() {
              var e4 = i3.next();
              return a = e4.done, e4;
            }, e: function(e4) {
              h = true, o2 = e4;
            }, f: function() {
              try {
                a || null == i3.return || i3.return();
              } finally {
                if (h) throw o2;
              }
            } };
          }
          function r(e3, t3) {
            (null == t3 || t3 > e3.length) && (t3 = e3.length);
            for (var i3 = 0, n2 = Array(t3); i3 < t3; i3++) n2[i3] = e3[i3];
            return n2;
          }
          function s(e3) {
            return s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            }, s(e3);
          }
          function o(e3) {
            if (this.version = "0.10.11", this.scene, this.graphics, this.debugOptions = { enabled: false, maps: true, rays: true, graphics: { ray: 65280, rayPoint: 16711935, mapPoint: 65535, mapSegment: 255, mapBoundingBox: 16711680 } }, this._stats = { mappedObjects: { total: 0, static: 0, dynamic: 0, rectangleMaps: 0, polygonMaps: 0, circleMaps: 0, lineMaps: 0, containerMaps: 0, tilemapMaps: 0, matterMaps: 0 } }, this.boundingBox = false, this.mappedObjects = [], this.dynamicMappedObjects = [], this.mapSegmentCount = 0, void 0 !== e3) {
              if (void 0 === e3.boundingBox && void 0 !== e3.scene) {
                if (void 0 !== e3.scene.physics) e3.boundingBox = e3.scene.physics.world.bounds;
                else if (void 0 !== e3.scene.matter) {
                  var t3 = e3.scene.matter.world.walls;
                  null !== t3.top && (e3.boundingBox = new Phaser.Geom.Rectangle(t3.top.vertices[3].x, t3.top.vertices[3].y, t3.bottom.vertices[1].x - t3.top.vertices[3].x, t3.bottom.vertices[1].y - t3.top.vertices[3].y));
                }
              }
              this.setOptions(e3), (void 0 === e3.autoUpdate || e3.autoUpdate) && this.scene.events.on("update", this.update, this);
            } else this.scene.events.on("update", this.update, this);
            return this;
          }
          i2.d(t2, { t: function() {
            return o;
          } }), o.prototype = { setOptions: function(e3) {
            return void 0 !== e3.scene && (this.scene = e3.scene, this.graphics = this.scene.add.graphics({ lineStyle: { width: 1, color: 65280 }, fillStyle: { color: 16711935 } }), this.graphics.setDepth(999)), void 0 !== e3.debug && false !== e3.debug && (this.debugOptions.enabled = true, "object" === s(e3.debug) && Object.assign(this.debugOptions, e3.debug)), void 0 !== e3.mapSegmentCount && (this.mapSegmentCount = e3.mapSegmentCount), void 0 !== e3.objects && this.mapGameObjects(e3.objects), void 0 !== e3.boundingBox && this.setBoundingBox(e3.boundingBox.x, e3.boundingBox.y, e3.boundingBox.width, e3.boundingBox.height), this;
          }, setBoundingBox: function(e3, t3, i3, n2) {
            this.boundingBox = { rectangle: new Phaser.Geom.Rectangle(e3, t3, i3, n2), points: [], segments: [] };
            var r2 = [new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top), new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top), new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom), new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)];
            this.boundingBox.points = r2;
            for (var s2 = 0, o2 = this.boundingBox.points.length; s2 < o2; s2++) s2 + 1 < o2 ? this.boundingBox.segments.push(new Phaser.Geom.Line(r2[s2].x, r2[s2].y, r2[s2 + 1].x, r2[s2 + 1].y)) : this.boundingBox.segments.push(new Phaser.Geom.Line(r2[s2].x, r2[s2].y, r2[0].x, r2[0].y));
          }, mapGameObjects: function(e3) {
            var t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            i3.dynamic = t3, i3.segmentCount = void 0 !== i3.segmentCount ? i3.segmentCount : this.segmentCount, Array.isArray(e3) || (e3 = [e3]);
            var r2, s2 = n(e3);
            try {
              for (s2.s(); !(r2 = s2.n()).done; ) {
                var o2 = r2.value;
                if (!this.mappedObjects.includes(o2) && (!o2.data || !o2.data.get("raycasterMapNotSupported"))) {
                  var a = {};
                  for (var h in i3) a[h] = i3[h];
                  a.object = o2;
                  var c = new this.Map(a, this);
                  if (c.notSupported) c.destroy();
                  else switch ("body" === o2.type || "composite" === o2.type ? o2.raycasterMap = c : (o2.data || o2.setDataEnabled(), o2.data.set("raycasterMap", c)), this.mappedObjects.push(o2), o2.type) {
                    case "Polygon":
                      this._stats.mappedObjects.polygonMaps++;
                      break;
                    case "Arc":
                      this._stats.mappedObjects.circleMaps++;
                      break;
                    case "Line":
                      this._stats.mappedObjects.lineMaps++;
                      break;
                    case "Container":
                      this._stats.mappedObjects.containerMaps++;
                      break;
                    case "StaticTilemapLayer":
                    case "DynamicTilemapLayer":
                    case "TilemapLayer":
                      this._stats.mappedObjects.tilemapMaps++;
                      break;
                    case "MatterBody":
                      this._stats.mappedObjects.matterMaps++;
                      break;
                    default:
                      this._stats.mappedObjects.rectangleMaps++;
                  }
                }
              }
            } catch (e4) {
              s2.e(e4);
            } finally {
              s2.f();
            }
            return this._stats.mappedObjects.total = this.mappedObjects.length, this._stats.mappedObjects.static = this._stats.mappedObjects.total - this.dynamicMappedObjects.length, this;
          }, removeMappedObjects: function(e3) {
            Array.isArray(e3) || (e3 = [e3]);
            var t3, i3 = n(e3);
            try {
              for (i3.s(); !(t3 = i3.n()).done; ) {
                var r2 = t3.value, s2 = this.mappedObjects.indexOf(r2);
                if (-1 !== s2) switch (this.mappedObjects.splice(s2, 1), (s2 = this.dynamicMappedObjects.indexOf(r2)) >= 0 && this.dynamicMappedObjects.splice(s2, 1), "body" === r2.type || "composite" === r2.type ? r2.raycasterMap.destroy() : r2.data.get("raycasterMap").destroy(), r2.type) {
                  case "Polygon":
                    this._stats.mappedObjects.polygonMaps--;
                    break;
                  case "Arc":
                    this._stats.mappedObjects.circleMaps--;
                    break;
                  case "Line":
                    this._stats.mappedObjects.lineMaps--;
                    break;
                  case "Container":
                    this._stats.mappedObjects.containerMaps--;
                    break;
                  case "StaticTilemapLayer":
                  case "DynamicTilemapLayer":
                  case "TilemapLayer":
                    this._stats.mappedObjects.tilemapMaps--;
                    break;
                  case "MatterBody":
                    this._stats.mappedObjects.matterMaps--;
                    break;
                  default:
                    this._stats.mappedObjects.rectangleMaps--;
                }
              }
            } catch (e4) {
              i3.e(e4);
            } finally {
              i3.f();
            }
            return this._stats.mappedObjects.total = this.mappedObjects.length, this._stats.mappedObjects.dynamic = this.dynamicMappedObjects.length, this._stats.mappedObjects.static = this._stats.mappedObjects.total - this.dynamicMappedObjects.length, this;
          }, enableMaps: function(e3) {
            Array.isArray(e3) || (e3 = [e3]);
            var t3, i3 = n(e3);
            try {
              for (i3.s(); !(t3 = i3.n()).done; ) {
                var r2 = t3.value, s2 = void 0;
                "body" === r2.type || "composite" === r2.type ? s2 = r2.raycasterMap : r2.data && (s2 = r2.data.get("raycasterMap")), s2 && (s2.active = true);
              }
            } catch (e4) {
              i3.e(e4);
            } finally {
              i3.f();
            }
            return this;
          }, disableMaps: function(e3) {
            Array.isArray(e3) || (e3 = [e3]);
            var t3, i3 = n(e3);
            try {
              for (i3.s(); !(t3 = i3.n()).done; ) {
                var r2 = t3.value, s2 = void 0;
                "body" === r2.type || "composite" === r2.type ? s2 = r2.raycasterMap : r2.data && (s2 = r2.data.get("raycasterMap")), s2 && (s2.active = false);
              }
            } catch (e4) {
              i3.e(e4);
            } finally {
              i3.f();
            }
            return this;
          }, update: function() {
            if (this.dynamicMappedObjects.length > 0) {
              var e3, t3 = n(this.dynamicMappedObjects);
              try {
                for (t3.s(); !(e3 = t3.n()).done; ) {
                  var i3 = e3.value, r2 = void 0;
                  "body" === i3.type || "composite" === i3.type ? r2 = i3.raycasterMap : i3.data && (r2 = i3.data.get("raycasterMap")), r2 && (r2.active && r2.updateMap());
                }
              } catch (e4) {
                t3.e(e4);
              } finally {
                t3.f();
              }
            }
            return this.debugOptions.enabled && this.drawDebug(), this;
          }, createRay: function() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return new this.Ray(e3, this);
          }, getStats: function() {
            return this._stats;
          }, drawDebug: function() {
            if (void 0 === this.graphics || !this.debugOptions.enabled) return this;
            if (this.graphics.clear(), !this.debugOptions.maps) return this;
            var e3, t3 = n(this.mappedObjects);
            try {
              for (t3.s(); !(e3 = t3.n()).done; ) {
                var i3 = e3.value, r2 = void 0;
                if ("body" === i3.type || "composite" === i3.type ? r2 = i3.raycasterMap : i3.data && (r2 = i3.data.get("raycasterMap")), r2) {
                  if (this.debugOptions.graphics.mapBoundingBox && (this.graphics.lineStyle(1, this.debugOptions.graphics.mapBoundingBox), this.graphics.strokeRectShape(r2.getBoundingBox())), this.debugOptions.graphics.mapSegment) {
                    this.graphics.lineStyle(1, this.debugOptions.graphics.mapSegment);
                    var s2, o2 = n(r2.getSegments());
                    try {
                      for (o2.s(); !(s2 = o2.n()).done; ) {
                        var a = s2.value;
                        this.graphics.strokeLineShape(a);
                      }
                    } catch (e4) {
                      o2.e(e4);
                    } finally {
                      o2.f();
                    }
                  }
                  if (this.debugOptions.graphics.mapPoint) {
                    this.graphics.fillStyle(this.debugOptions.graphics.mapPoint);
                    var h, c = n(r2.getPoints());
                    try {
                      for (c.s(); !(h = c.n()).done; ) {
                        var l = h.value;
                        this.graphics.fillPoint(l.x, l.y, 3);
                      }
                    } catch (e4) {
                      c.e(e4);
                    } finally {
                      c.f();
                    }
                  }
                }
              }
            } catch (e4) {
              t3.e(e4);
            } finally {
              t3.f();
            }
            return this;
          }, destroy: function() {
            for (var e3 in this.removeMappedObjects(this.mappedObjects), this.graphics && this.graphics.destroy(), this.scene && this.scene.events.removeListener("update", null, this), this) delete this[e3];
          } }, o.prototype.Map = i2(465).T, o.prototype.Ray = i2(689).R;
        } }, t = {};
        function i(n) {
          var r = t[n];
          if (void 0 !== r) return r.exports;
          var s = t[n] = { exports: {} };
          return e[n](s, s.exports, i), s.exports;
        }
        return i.d = function(e2, t2) {
          for (var n in t2) i.o(t2, n) && !i.o(e2, n) && Object.defineProperty(e2, n, { enumerable: true, get: t2[n] });
        }, i.o = function(e2, t2) {
          return Object.prototype.hasOwnProperty.call(e2, t2);
        }, i.r = function(e2) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
        }, i(781);
      }();
    });
  }
});
export default require_phaser_raycaster_min();
/*! Bundled license information:

phaser-raycaster/dist/phaser-raycaster.min.js:
  (**
  * @author       Marcin Walczak <contact@marcin-walczak.pl>
  * @copyright    2023 Marcin Walczak
  * @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}
  *)
*/
//# sourceMappingURL=phaser-raycaster.js.map
