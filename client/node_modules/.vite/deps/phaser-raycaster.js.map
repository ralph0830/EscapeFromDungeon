{
  "version": 3,
  "sources": ["../../phaser-raycaster/dist/webpack:/PhaserRaycaster/webpack/universalModuleDefinition", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/main.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/map/boundingBox.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/map/config.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/map/destroy.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/map/map-circle-methods.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/map/map-container-methods.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/map/map-core.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/map/map-line-methods.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/map/map-matterBody-methods.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/map/map-polygon-methods.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/map/map-rectangle-methods.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/map/map-tilemap-methods.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/map/segmentsCount.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/ray/angle.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/ray/cast.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/ray/castCircle.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/ray/castCone.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/ray/cone.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/ray/config.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/ray/debug.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/ray/destroy.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/ray/enablePhysics.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/ray/matter-physics-methods.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/ray/origin.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/ray/overlap.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/ray/range.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/ray/ray-core.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/ray/ray.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/ray/slice.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/ray/stats.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/src/raycaster-core.js", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/webpack/bootstrap", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/webpack/runtime/define property getters", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/webpack/runtime/hasOwnProperty shorthand", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/webpack/runtime/make namespace object", "../../phaser-raycaster/dist/webpack:/PhaserRaycaster/webpack/startup"],
  "sourcesContent": ["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(self, function() {\nreturn ", "/**\r\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\r\n* @copyright    2023 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/**\r\n * Point object\r\n * @typedef {Object} Point\r\n * @property {number} x\r\n * @property {number} y\r\n */\r\n \r\n/**\r\n * @classdesc\r\n *\r\n * Raycaster plugin class.\r\n * \r\n * @namespace PhaserRaycaster\r\n * @class PhaserRaycaster\r\n * @extends Phaser.Plugins.ScenePlugin\r\n * @constructor\r\n * @since 0.6.0\r\n *\r\n * @param {Phaser.Scene} scene\r\n * @param {Phaser.Plugins.PluginManager} pluginManager\r\n */\r\n\r\nclass PhaserRaycaster extends Phaser.Plugins.ScenePlugin {\r\n    constructor(scene, pluginManager) {\r\n        super(scene, pluginManager);\r\n\r\n        this._Raycaster = require('./raycaster-core.js').Raycaster;\r\n    }\r\n\r\n    /**\r\n    * Create Raycaster object.\r\n    *\r\n    * @method PhaserRaycaster#createRaycaster\r\n    * @memberof PhaserRaycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\r\n    * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\r\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. If not passed, {@link Raycaster Raycaster} will set it's bounding box based on Arcade Physics / Matter physics world bounds.\r\n    * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\r\n    * @param {boolean|object} [options.debug] - Enable debug mode or configure it {@link Raycaster#debugOptions debugOptions}.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    createRaycaster(options = {}) {\r\n        options.scene = this.scene;\r\n        return new this._Raycaster(options);\r\n    }\r\n}\r\n\r\n//Make sure you export the plugin for webpack to expose\r\nmodule.exports = PhaserRaycaster;", "/**\r\n* Get mapped object's bounding box.\r\n*\r\n* @method Raycaster.Map#matterBody.getBoundingBox\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Phaser.Geom.Rectangle} - Mapped object's bounding box.\r\n*/\r\nexport function getBoundingBox() {\r\n    return this.object.getBounds();\r\n}\r\n", "let rectangle = require('./map-rectangle-methods.js');\r\nlet line = require('./map-line-methods.js');\r\nlet polygon = require('./map-polygon-methods.js');\r\nlet arc = require('./map-circle-methods.js');\r\nlet container = require('./map-container-methods.js');\r\nlet tilemap = require('./map-tilemap-methods.js');\r\nlet matterBody = require('./map-matterBody-methods.js');\r\nlet segmentCount = require('./segmentsCount.js');\r\nlet boundingBox = require('./boundingBox.js');\r\n\r\n/**\r\n * Configure map.\r\n *\r\n * @method Raycaster.Map#config\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Map's congfiguration options. May include:\r\n * @param {object} options.object - Game object to map\r\n * @param {string} [options.type] - Map type. If not defined, it will be determined based on object.\r\n * @param {boolean} [options.dynamic = false] - If set true, map will be dynamic (updated on scene update event).\r\n * @param {boolean} [options.active = true] - If set true, map will be active (will provide points, segments and will be updated).\r\n * @param {number} [options.segmentCount] - Circle map's segment count. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\r\n * @param {object} [options.mapChild] - Container's child. If set, only set child will be mapped.\r\n * @param {boolean} [options.forceConvex] - If set true, matter body map will use convex body (hull) for non-covex bodies.\r\n * @param {boolean} [options.forceVerticesMapping] - If set true, matter body map will use only vertices for mapping circle bodies.\r\n * \r\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n */\r\nexport function config(options) {\r\n    this.object = options.object;\r\n    //object type\r\n    if(options.type === undefined)\r\n        options.type = options.object.type;\r\n    if(options.type === 'body' || options.type === 'composite')\r\n        options.type = 'MatterBody';\r\n    this.type = options.type;\r\n    \r\n    switch(options.type) {\r\n        case 'Polygon':\r\n            this.getPoints = polygon.getPoints;\r\n            this.getSegments = polygon.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = polygon.updateMap;\r\n            break;\r\n        case 'Arc':\r\n            //circle segments count\r\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\r\n            this.circle = (options.segmentCount) ? false : true;\r\n            this.getPoints = arc.getPoints;\r\n            this.getSegments = arc.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = arc.updateMap;\r\n            this.setSegmentCount = segmentCount.setSegmentCount;\r\n            break;\r\n        case 'Line':\r\n            this.getPoints = line.getPoints;\r\n            this.getSegments = line.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = line.updateMap;\r\n            break;\r\n        case 'Container':\r\n            //container's child\r\n            this.mapChild = (options.mapChild) ? options.mapChild : null;\r\n            //circle segments count\r\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\r\n            //transformed container's circle children\r\n            this._circles = [];\r\n            this.getPoints = container.getPoints;\r\n            this.getSegments = container.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = container.updateMap;\r\n            this._updateChildMap = container._updateChildMap;\r\n            this.setSegmentCount = segmentCount.setSegmentCount;\r\n            break;\r\n        case 'StaticTilemapLayer':\r\n            //ray colliding tiles\r\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\r\n            this.getPoints = tilemap.getPoints;\r\n            this.getSegments = tilemap.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = tilemap.updateMap;\r\n            this.setCollisionTiles = tilemap.setCollisionTiles;\r\n            //reset tilemap origin\r\n            this.object.setOrigin(0,0);\r\n            break;\r\n        case 'DynamicTilemapLayer':\r\n            //ray colliding tiles\r\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\r\n            this.getPoints = tilemap.getPoints;\r\n            this.getSegments = tilemap.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = tilemap.updateMap;\r\n            this.setCollisionTiles = tilemap.setCollisionTiles;\r\n            //reset tilemap origin\r\n            this.object.setOrigin(0,0);\r\n            break;\r\n        case 'TilemapLayer':\r\n            //ray colliding tiles\r\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\r\n            this.getPoints = tilemap.getPoints;\r\n            this.getSegments = tilemap.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = tilemap.updateMap;\r\n            this.setCollisionTiles = tilemap.setCollisionTiles;\r\n            //reset tilemap origin\r\n            this.object.setOrigin(0,0);\r\n            break;\r\n        case 'MatterBody':\r\n            //force convex body (hull) mapping\r\n            this.forceConvex = (options.forceConvex) ? true : false;\r\n            //force mapping by vertices\r\n            this.forceVerticesMapping = (options.forceVerticesMapping) ? true : false;\r\n            this.circle = false;\r\n            this.getPoints = matterBody.getPoints;\r\n            this.getSegments = matterBody.getSegments;\r\n            this.getBoundingBox = matterBody.getBoundingBox;\r\n            this.updateMap = matterBody.updateMap;\r\n            break;\r\n        default:\r\n            this.getPoints = rectangle.getPoints;\r\n            this.getSegments = rectangle.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = rectangle.updateMap;\r\n    }\r\n\r\n    //if object is not supported\r\n    if(this.type != 'MatterBody' && typeof this.object.getBounds !== 'function') {\r\n        this.notSupported = true;\r\n    }\r\n\r\n    //dynamic map\r\n    this.dynamic = (options.dynamic == true) ? true : false;\r\n\r\n    //enable/disable map\r\n    this.active = (options.active !== undefined) ? options.active : true;\r\n\r\n    return this;\r\n}\r\n", "/**\r\n * Destroy object\r\n *\r\n * @method Raycaster.Map#destroy\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.10.3\r\n */\r\n export function destroy() {\r\n    //destroy reference to map object in mapped object\r\n    if(this.object.type === 'body' || this.object.type === 'composite') {\r\n        delete this.object.raycasterMap;\r\n    }\r\n    else if(this.object.data) {\r\n        this.object.data.remove('raycasterMap');\r\n    }\r\n\r\n    for(let key in this) {\r\n        delete this[key];\r\n    }\r\n }", "/*Map methods for circles*/\r\n/**\r\n* Get array of mapped circle's vertices used as rays targets.\r\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll calculatoe tangent points for passed ray.\r\n*\r\n* @method Raycaster.Map#arc.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    if(this._points.length > 0)\r\n        return this._points;\r\n    \r\n    let points = [];\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\r\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\r\n\r\n    //calculate tangent rays\r\n    if(ray) {\r\n        let rayA = new Phaser.Geom.Line();\r\n        let rayB = new Phaser.Geom.Line();\r\n        let c;\r\n        \r\n        let rotation = this.object.rotation;\r\n        \r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            let cB = vector.getPointB();\r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\r\n        }\r\n        else { \r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\r\n        }\r\n\r\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\r\n\r\n        //ray angle\r\n        let angle = Phaser.Geom.Line.Angle(c);\r\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\r\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n        //add tangent points\r\n        points.push(rayA.getPointB());\r\n        points.push(rayB.getPointB());\r\n        //assign neighbours\r\n        points[0].neighbours = [points[1]];\r\n        points[1].neighbours = [points[0]];\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n/**\r\n* Get array of mapped circle's segments used to test object's intersection with ray.\r\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll return empty array.\r\n*\r\n* @method Raycaster.Map#arc.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update circles's map of points and segments.\r\n*\r\n* @method Raycaster.Map#arc.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n    \r\n    if(!this.segmentCount) {\r\n        this._points = [];\r\n        this._segments = [];\r\n        return this;\r\n    }\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\r\n\r\n    //get points surrounding circle\r\n    let points = this.object.geom.getPoints(this.segmentCount);\r\n    let segments = []\r\n\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let newPoints = [];\r\n        for(let point of points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            newPoints.push(vector.getPointB());\r\n        }\r\n        points = newPoints;\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of points) {\r\n            point.x = point.x * this.object.scaleX + offset.x;\r\n            point.y = point.y * this.object.scaleY + offset.y;\r\n        }\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        let prevPoint = i > 0 ? points[i - 1] : points.slice(-1)[0],\r\n            nextPoint = i < length - 1 ? points[i + 1] : points[0];\r\n\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, nextPoint.x, nextPoint.y));\r\n        \r\n        points[i].neighbours = [\r\n            prevPoint,\r\n            nextPoint\r\n        ];\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n", "/*Map methods for containers*/\r\n/**\r\n* Get array of mapped container's and its children vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#container.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.1\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n* @param {boolean} [isChild] - Flag definig if it is child container.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false, isChild = false) {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    let points = this._points;\r\n    //calculate offset based on container position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n\r\n    //get tangent points of container's circles\r\n    if(this.segmentCount == 0 && !isChild) {\r\n        if(ray) {\r\n            //create temporary ray\r\n            let vector = new Phaser.Geom.Line(0, 0, ray.origin.x - offset.x, ray.origin.y - offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) - this.object.rotation, Phaser.Geom.Line.Length(vector));\r\n\r\n            //calculate tangent rays\r\n            let rayA = new Phaser.Geom.Line(),\r\n                rayB = new Phaser.Geom.Line(),\r\n                c;\r\n\r\n            for(let circle of this._circles) {\r\n                circle.points = [];\r\n                c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, circle.x, circle.y);\r\n\r\n                let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(circle.radius, 2));\r\n\r\n                //ray angle\r\n                let angle = Phaser.Geom.Line.Angle(c);\r\n                let dAngle = Math.asin((circle.radius) / Phaser.Geom.Line.Length(c));\r\n                Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n                Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n                //adding tangent points\r\n                circle.points.push(rayA.getPointB());\r\n                circle.points.push(rayB.getPointB());\r\n                points.push(rayA.getPointB());\r\n                points.push(rayB.getPointB());\r\n            }\r\n        }\r\n    }\r\n    \r\n    return points;\r\n};\r\n\r\n/**\r\n* Get array of mapped container's and its children segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#container.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.1\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update container's and its children maps of points and segments.\r\n*\r\n* @method Raycaster.Map#container.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.1\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    let container = this.object;\r\n    this._circles = [];\r\n\r\n    //calculate offset based on container position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n\r\n    let rotation = container.rotation;\r\n\r\n    if(this.mapChild) {\r\n        this._updateChildMap(this.mapChild, points, segments, rotation, offset);\r\n    }\r\n    else {\r\n        //iterate through container's children\r\n        container.iterate(function(child){\r\n            this._updateChildMap(child, points, segments, rotation, offset);\r\n        }.bind(this));\r\n\r\n        //get children intersections\r\n        for(let i = 0, iLength = container.list.length; i < iLength; i++){\r\n            let childA = container.list[i];\r\n            let mapA = childA.data.get('raycasterMap');\r\n            \r\n            if(!mapA)\r\n                continue;\r\n\r\n            for(let j = i+1, jLength = container.list.length; j < jLength; j++){\r\n                let childB = container.list[j];\r\n                let mapB = childB.data.get('raycasterMap');\r\n                //check if bounding boxes overlap\r\n                if(!mapB || !Phaser.Geom.Intersects.RectangleToRectangle(childA.getBounds(), childB.getBounds()))\r\n                    continue;\r\n\r\n                //find objects intersections\r\n                for(let segmentA of mapA.getSegments()) {\r\n                    for(let segmentB of mapB.getSegments()) {\r\n                        let intersection = [];\r\n                        if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                            continue;\r\n                        \r\n                        //calculate positions after container's rotation\r\n                        if(rotation !== 0) {\r\n                            let vector = new Phaser.Geom.Line(container.x, container.y, intersection.x * container.scaleX + offset.x, intersection.y * container.scaleY + offset.y);\r\n                            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                            points.push(vector.getPointB());\r\n                        }\r\n                        //if rotation === 0\r\n                        else\r\n                            points.push(new Phaser.Geom.Point(intersection.x * container.scaleX + offset.x, intersection.y * container.scaleX + offset.y));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n* Update container's child map of points and segments.\r\n*\r\n* @method Raycaster.Map#container._updateChildMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.10.3\r\n*\r\n* @param {object} [child] - Container's child object.\r\n* @param {Phaser.Geom.Point[]} [points] - Container's mapped points.\r\n* @param {Phaser.Geom.Line[]} [segments] - Container's mapped segments.\r\n* @param {number} [rotation] - Container's rotation.\r\n* @param {Phaser.Geom.Point} [offset] - Container's offset.\r\n*/\r\nexport function _updateChildMap(child, points, segments, rotation, offset) {\r\n    if(!child.data)\r\n        child.setDataEnabled();\r\n\r\n    //if object is not supported\r\n    if(child.data.get('raycasterMapNotSupported'))\r\n        return;\r\n\r\n    //get child map\r\n    let map = child.data.get('raycasterMap');\r\n    if(!map) {\r\n        map = new this.constructor({\r\n            object: child,\r\n            segmentCount: this.segmentCount\r\n        });\r\n\r\n        if(map.notSupported) {\r\n            map.destroy();\r\n            child.data.set('raycasterMapNotSupported', true);\r\n            return;\r\n        }\r\n\r\n        child.data.set('raycasterMap', map);\r\n    }\r\n    else\r\n        map.updateMap();\r\n\r\n    //add child points\r\n    let childPoints = [];\r\n    for(let point of map.getPoints(false, true)) {\r\n        let childPoint;\r\n\r\n        //calculate positions after container's rotation\r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            childPoint = vector.getPointB();\r\n        }\r\n        //if rotation === 0\r\n        else\r\n            childPoint = new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleX + offset.y);\r\n\r\n        //add neighbour points\r\n        childPoint.neighbours = [];\r\n        if(childPoints.length > 0) {\r\n            let previousPoint = childPoints.slice(-1)[0];\r\n            previousPoint.neighbours.push(childPoint);\r\n            childPoint.neighbours.push(previousPoint);\r\n        }\r\n        \r\n        childPoints.push(childPoint);\r\n        points.push(childPoint);\r\n    }\r\n\r\n    //add neighbour point to last child point\r\n    if(childPoints.length > 0) {\r\n        childPoints.slice(-1)[0].neighbours.push(childPoints[0]);\r\n    }\r\n\r\n    //add child segments\r\n    for(let segment of map.getSegments()) {\r\n        //calculate positions after container's rotation\r\n        if(rotation !== 0) {\r\n            let pointA = segment.getPointA();\r\n            let pointB = segment.getPointB();\r\n            let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\r\n            let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\r\n            Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\r\n\r\n            segments.push(new Phaser.Geom.Line(vectorA.getPointB().x, vectorA.getPointB().y, vectorB.getPointB().x, vectorB.getPointB().y));\r\n        }\r\n        //if rotation === 0\r\n        else\r\n            segments.push(new Phaser.Geom.Line(segment.getPointA().x * this.object.scaleX + offset.x, segment.getPointA().y * this.object.scaleY + offset.y, segment.getPointB().x * this.object.scaleX + offset.x, segment.getPointB().y * this.object.scaleY + offset.y));\r\n    }\r\n\r\n    //if child's map is a circle and this.segmentsCount == 0, store transformed circles in this._circles array.\r\n    if(map.type == 'Arc' && this.segmentCount == 0) {\r\n        let circleOffset = new Phaser.Geom.Point();\r\n        circleOffset.x = (map.object.x - map.object.displayWidth * (map.object.originX - 0.5)) * this.object.scaleX + offset.x;\r\n        circleOffset.y = (map.object.y - map.object.displayHeight * (map.object.originY - 0.5))  * this.object.scaleY + offset.y;\r\n\r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, circleOffset.x, circleOffset.y)\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            circleOffset = vector.getPointB();\r\n        }\r\n\r\n        this._circles.push(new Phaser.Geom.Circle(circleOffset.x, circleOffset.y, map.object.radius * map.object.scaleX * this.object.scaleX));\r\n    }\r\n    else if(map.type === 'Container') {\r\n        for(let childMapCircle of map._circles) {\r\n            let circleOffset = new Phaser.Geom.Point();\r\n                circleOffset.x = childMapCircle.x * this.object.scaleX + offset.x;\r\n                circleOffset.y = childMapCircle.y * this.object.scaleY + offset.y;\r\n\r\n            if(rotation !== 0) {\r\n                let vector = new Phaser.Geom.Line(this.object.x, this.object.y, circleOffset.x, circleOffset.y)\r\n                Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                circleOffset = vector.getPointB();\r\n            }\r\n\r\n            this._circles.push(new Phaser.Geom.Circle(circleOffset.x, circleOffset.y, childMapCircle.radius * this.object.scaleX));\r\n        }\r\n    }\r\n}\r\n", "/**\r\n * @classdesc\r\n *\r\n * Map class responsible for mapping game objects.\r\n *\r\n * @namespace Raycaster.Map\r\n * @class Raycaster.Map\r\n * @constructor\r\n * @since 0.6.0\r\n *\r\n * @param {object} options - Map specific configuration settings.\r\n * @param {Raycaster} [raycaster] - Parent raycaster object.\r\n */\r\nexport function Map(options, raycaster) {\r\n    /**\r\n    * Reference to parent Raycaster object.\r\n    *\r\n    * @name Raycaster.Map#_raycaster\r\n    * @type {Raycaster}\r\n    * @private\r\n    * @since 0.9.0\r\n    */\r\n    this._raycaster = raycaster ? raycaster : false;\r\n    /**\r\n    * Mapped object's type\r\n    *\r\n    * @name Raycaster.Map#type\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.type;\r\n    /**\r\n    * If set true, map will be tested by ray. Otherwise it will be ignored.\r\n    *\r\n    * @name Raycaster.Map#active\r\n    * @type {boolean}\r\n    * @default true\r\n    * @since 0.7.2\r\n    */\r\n    this.active;\r\n    /**\r\n    * If set true, map will be automatically updated on scene update event.\r\n    *\r\n    * @name Raycaster.Map_dynamic\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.6.0\r\n    */\r\n    this._dynamic = false;\r\n    /**\r\n    * If set true, map will be treated by ray as circle. Set automaticalyy on map update.\r\n    *\r\n    * @name Raycaster.Map#circle\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.9.0\r\n    */\r\n    this.circle = false;\r\n    /**\r\n    * Reference to mapped object.\r\n    *\r\n    * @name Raycaster.Map#object\r\n    * @type {object}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.object;\r\n    /**\r\n    * Array of mapped object's vertices used as rays targets.\r\n    *\r\n    * @name Raycaster.Map#_points\r\n    * @type {array}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._points = [];\r\n    /**\r\n    * Array of mapped object's segments used to test object's intersection with ray.\r\n    *\r\n    * @name Raycaster.Map#_segments\r\n    * @type {array}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._segments = [];\r\n    /**\r\n    * Get array of mapped object's vertices used as rays targets.\r\n    *\r\n    * @method Raycaster.Map#getPoints\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {Raycaster.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\r\n    *\r\n    * @return {Phaser.Geom.Point[]} Array of mapped object's vertices.\r\n    */\r\n    this.getPoints;\r\n    /**\r\n    * Get array of mapped object's segments used to test object's intersection with ray.\r\n    *\r\n    * @method Raycaster.Map#getSegments\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {Raycaster.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\r\n    *\r\n    * @return {Phaser.Geom.Line[]} Array of mapped object's segments.\r\n    */\r\n    this.getSegments;\r\n    /**\r\n    * Get mapped object's bounding box.\r\n    *\r\n    * @method Raycaster.Map#getBoundingBox\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.9.0\r\n    *\r\n    * @return {Phaser.Geom.Rectangle} Mapped object's bounding box.\r\n    */\r\n    this.getBoundingBox;\r\n    /**\r\n    * Update object's map of points and segments.\r\n    *\r\n    * @method Raycaster.Map#updateMap\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n    */\r\n    this.updateMap;\r\n\r\n    this.config(options);\r\n    if(!this.notSupported)\r\n        this.updateMap();\r\n\r\n    return this;\r\n};\r\n\r\nMap.prototype = {\r\n    config: require('./config.js').config,\r\n    destroy: require('./destroy.js').destroy,\r\n    get dynamic() {\r\n        return this._dynamic;\r\n    },\r\n    set dynamic(dynamic) {\r\n        if(this._dynamic == dynamic)\r\n            return this;\r\n    \r\n        if(dynamic) {\r\n            this._dynamic = true;\r\n            \r\n            //add object to raycaster's dynamic objects list\r\n            if(this._raycaster) {\r\n                this._raycaster.dynamicMappedObjects.push(this.object);\r\n    \r\n                this._raycaster._stats.mappedObjects.dynamic = this._raycaster.dynamicMappedObjects.length;\r\n                this._raycaster._stats.mappedObjects.static = this._raycaster._stats.mappedObjects.total - this._raycaster._stats.mappedObjects.dynamic;\r\n            }\r\n        }\r\n        else {\r\n            this._dynamic = false;\r\n            \r\n            //remove object from reycasters' dynamic objects list\r\n            if(this._raycaster) {\r\n                let index = this._raycaster.dynamicMappedObjects.indexOf(this.object);\r\n                if(index >= 0)\r\n                    this._raycaster.dynamicMappedObjects.splice(index, 1);\r\n    \r\n                this._raycaster._stats.mappedObjects.dynamic = this._raycaster.dynamicMappedObjects.length;\r\n                this._raycaster._stats.mappedObjects.static = this._raycaster._stats.mappedObjects.total - this._raycaster._stats.mappedObjects.dynamic;\r\n            }\r\n        }\r\n    \r\n        return this;\r\n     }\r\n};\r\n\r\nMap.prototype.constructor = Map;\r\n", "/*Map methods for lines*/\r\n/**\r\n* Get array of mapped line's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#line.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped line's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#line.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update line's map of points and segments.\r\n*\r\n* @method Raycaster.Map#line.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    let pointA = this.object.geom.getPointA();\r\n    let pointB = this.object.geom.getPointB();\r\n\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\r\n        pointA = vectorA.getPointB();\r\n\r\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\r\n        pointB = vectorB.getPointB();\r\n\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y, pointB.x + offset.x * this.object.scaleX, pointB.y * this.object.scaleY + offset.y));\r\n    }\r\n    \r\n    //assign neighbours\r\n    points[0].neighbours = [points[1]];\r\n    points[1].neighbours = [points[0]];\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n", "/*Map methods for matter body*/\r\n/**\r\n* Get array of mapped matter body's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#matterBody.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\r\n\r\n    //calculate tangent rays\r\n    if(ray && !this.forceVerticesMapping && body.circleRadius > 0) {\r\n        let points = [];\r\n        let rayA = new Phaser.Geom.Line();\r\n        let rayB = new Phaser.Geom.Line();\r\n        let c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, body.position.x, body.position.y);\r\n\r\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(body.circleRadius * body.scale.x, 2));\r\n\r\n        //ray angle\r\n        let angle = Phaser.Geom.Line.Angle(c);\r\n        let dAngle = Math.asin((body.circleRadius * body.scale.x) / Phaser.Geom.Line.Length(c));\r\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n        //adding tangent points\r\n        points.push(rayA.getPointB(), rayB.getPointB());\r\n\r\n        return points;\r\n    }\r\n\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped matter body's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#matterBody.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update matter body's map of points and segments.\r\n*\r\n* @method Raycaster.Map#matterBody.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\r\n    let bodies = [body];\r\n    let generateBounds = false;\r\n\r\n    if(body.circleRadius > 0 && !this.forceVerticesMapping) {\r\n        this.circle = true;\r\n        this._points = points;\r\n        this._segments = segments;\r\n\r\n        return this;\r\n    }\r\n\r\n    this.circle = false;\r\n\r\n    if(body.type == 'composite')\r\n        bodies = body.bodies;\r\n\r\n    if( ( body.bounds === undefined && body.type == 'composite' ) || ( body.type == 'composite' && this.dynamic ) ) {\r\n        generateBounds = true;\r\n    }\r\n    \r\n    for(let bodyItem of bodies) {\r\n        //if convex body\r\n        if(bodyItem.parts.length === 1 || this.forceConvex) {\r\n            let vertices = bodyItem.parts[0].vertices;\r\n\r\n            points.push(new Phaser.Geom.Point(vertices[0].x, vertices[0].y));\r\n            points[0].neighbours = [];\r\n\r\n            for(let i = 1, length = vertices.length; i < length; i++) {\r\n                let pointA = points.slice(-1)[0],\r\n                    pointB = new Phaser.Geom.Point(vertices[i].x, vertices[i].y);\r\n                    \r\n                if(!pointA.neighbours)\r\n                    pointA.neighbours = [];\r\n                pointA.neighbours.push(pointB);\r\n                pointB.neighbours = [pointA];\r\n\r\n                points.push(pointB);\r\n\r\n                //add segment\r\n                let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\r\n                segments.push(segment);\r\n            }\r\n\r\n            //closing segment\r\n            let segment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\r\n            segments.push(segment);\r\n\r\n            points[0].neighbours.push(points.slice(-1)[0]);\r\n        }\r\n\r\n        //if concave body\r\n        else {\r\n            let parts = [],\r\n                indexedPoints = [];\r\n\r\n            for(let i = 1, iLength = bodyItem.parts.length; i < iLength; i++) {\r\n                let vertices = bodyItem.parts[i].vertices,\r\n                    part = [];\r\n                \r\n                for(let j = 0, jLength = vertices.length; j < jLength; j++) {\r\n                    let point = new Phaser.Geom.Point(vertices[j].x, vertices[j].y);\r\n\r\n                    if(part.length) {\r\n                        let prevPoint = part.slice(-1)[0];\r\n                        point.neighbours = [prevPoint];\r\n                        prevPoint.neighbours.push(point);\r\n                    }\r\n                    else {\r\n                        point.neighbours = [];\r\n                    }\r\n\r\n                    let index = vertices[j].x + '/' + vertices[j].y;\r\n                    if(indexedPoints[index] === undefined) {\r\n                        points.push(point);\r\n                        indexedPoints[index] = point;\r\n                    }\r\n                    else {\r\n                        indexedPoints[index].neighbours.push(point);\r\n                        point.neighbours.push(indexedPoints[index]);\r\n                    }\r\n\r\n                    part.push(point);\r\n\r\n                    if(vertices[j].isInternal) {\r\n                        parts.push(part);\r\n                        part = [];\r\n                    }\r\n                }\r\n                parts.push(part);\r\n            }\r\n\r\n            for(let part of parts) {\r\n                let i = 0,\r\n                iLength;\r\n                for(i = 0, iLength = part.length - 1; i < iLength; i++) {\r\n                    segments.push(new Phaser.Geom.Line(part[i].x, part[i].y, part[i+1].x, part[i+1].y));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    if(generateBounds) {\r\n        let bounds = this._raycaster.scene.matter.composite.bounds(body);\r\n        body.bounds = bounds;\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n* Get matter body's bounding box.\r\n*\r\n* @method Raycaster.Map#matterBody.getBoundingBox\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Phaser.Geom.Rectangle} - Matter body's bounding box.\r\n*/\r\nexport function getBoundingBox() {\r\n    let bounds = this.object.type === 'body' || this.object.type === 'composite' ? this.object.bounds : this.object.body.bounds;\r\n\r\n    return new Phaser.Geom.Rectangle(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);\r\n}\r\n\r\n", "/*Map methods for polygons*/\r\n/**\r\n* Get array of mapped polygon's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#polygon.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped polygon's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#polygon.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update polygon's map of points and segments.\r\n*\r\n* @method Raycaster.Map#polygon.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        for(let point of this.object.geom.points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            points.push(vector.getPointB());\r\n        }\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of this.object.geom.points) {\r\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\r\n        }\r\n    }\r\n\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        let prevPoint = i > 0 ? points[i - 1] : points.slice(-1)[0],\r\n            nextPoint = i < length - 1 ? points[i + 1] : points[0];\r\n\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, nextPoint.x, nextPoint.y));\r\n        \r\n        points[i].neighbours = [\r\n            prevPoint,\r\n            nextPoint\r\n        ];\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \r\n    }\r\n    //if polygon is not closed\r\n    if(!this.object.closePath) {\r\n       segments.pop();\r\n       points[0].neighbours.shift();\r\n       points[points.length - 1].neighbours.pop();\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n", "/*Map methods for rectangles*/\r\n/**\r\n* Get array of mapped rectangle's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#rectangle.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped rectangle's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#rectangle.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update rectangle's map of points and segments.\r\n*\r\n* @method Raycaster.Map#rectangle.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n        \r\n    let points = [];\r\n    let segments = [];\r\n\r\n    //set points\r\n    points = [\r\n        this.object.getTopLeft(),\r\n        this.object.getTopRight(),\r\n        this.object.getBottomRight(),\r\n        this.object.getBottomLeft()\r\n    ];\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        let prevPoint = i > 0 ? points[i - 1] : points.slice(-1)[0],\r\n            nextPoint = i < length - 1 ? points[i + 1] : points[0];\r\n\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, nextPoint.x, nextPoint.y));\r\n        \r\n        points[i].neighbours = [\r\n            prevPoint,\r\n            nextPoint\r\n        ];\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n", "/*Map methods for tilemaps*/\r\n/**\r\n* Get array of mapped tilemap's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#tilemap.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.3\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\r\n        return this._points;\r\n\r\n    let points = [];\r\n    for(let point of this._points) {\r\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, point.x, point.y) <= ray.detectionRange)\r\n            points.push(point);\r\n    }\r\n\r\n    //get intersections between tilemap's segments and ray's detection range edge\r\n    let segments = this.getSegments(ray);\r\n\r\n    for(let segment of segments) {\r\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x1, segment.y1) > ray.detectionRange)\r\n            points.push(new Phaser.Geom.Point(segment.x1, segment.y1));\r\n        \r\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x2, segment.y2) > ray.detectionRange)\r\n            points.push(new Phaser.Geom.Point(segment.x2, segment.y2));\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n/**\r\n* Get array of mapped tilemap's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#tilemap.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.3\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    if(!ray || (ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER)))\r\n        return this._segments;\r\n\r\n    let segments = [];\r\n    for(let segment of this._segments) {\r\n        if(Phaser.Geom.Intersects.LineToCircle(segment, ray.detectionRangeCircle)) {\r\n            segments.push(segment);\r\n        }\r\n    }\r\n\r\n    return segments;\r\n};\r\n\r\n/**\r\n* Update tilemap's map of points and segments.\r\n*\r\n* @method Raycaster.Map#tilemap.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.3\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [],\r\n        segments = [],\r\n        columns = Array(this.object.layer.data[0].length + 1);\r\n        \r\n        for(let i = 0, iLength = columns.length; i < iLength; i++) {\r\n            columns[i] = [];\r\n        }\r\n\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point(this.object.x, this.object.y);\r\n\r\n    let row = this.object.layer.data[0],\r\n        tileWidth = this.object.layer.tileWidth * this.object.scaleX,\r\n        tileHeight = this.object.layer.tileHeight * this.object.scaleY,\r\n        startPoint,\r\n        endPoint;\r\n\r\n    //set top horizontal lines\r\n    if(this.collisionTiles.includes(row[0].index)) {\r\n        startPoint = new Phaser.Geom.Point(offset.x, offset.y);\r\n        endPoint = new Phaser.Geom.Point(tileWidth + offset.x, offset.y);\r\n\r\n        columns[0].push(startPoint);\r\n    }\r\n\r\n    for(let i = 1, iLength = row.length; i < iLength; i++) {\r\n        let tile = row[i];\r\n        \r\n        if(!this.collisionTiles.includes(tile.index)) {\r\n            if(startPoint) {\r\n                startPoint.neighbours = [endPoint];\r\n                endPoint.neighbours = [startPoint];\r\n\r\n                points.push(startPoint, endPoint);\r\n                segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\r\n\r\n                columns[i].push(endPoint);\r\n\r\n                startPoint = false;\r\n                endPoint = false;\r\n            }\r\n            continue;\r\n        }\r\n\r\n        let x = i * tileWidth + offset.x,\r\n            y = offset.y;\r\n\r\n        if(!startPoint) {\r\n            startPoint = new Phaser.Geom.Point(x, y);\r\n            columns[i].push(startPoint);\r\n        }\r\n\r\n        if(!endPoint) {\r\n            endPoint = new Phaser.Geom.Point(x + tileWidth, y);\r\n        }\r\n        else {\r\n            endPoint.x = x + tileWidth;\r\n        }\r\n    }\r\n\r\n    if(startPoint) {\r\n        startPoint.neighbours = [endPoint];\r\n        endPoint.neighbours = [startPoint];\r\n\r\n        points.push(startPoint, endPoint);\r\n        segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\r\n\r\n        columns[row.length].push(endPoint);\r\n    }\r\n\r\n    startPoint = false;\r\n    endPoint = false;\r\n\r\n    for(let i = 1, iLength = this.object.layer.data.length; i < iLength; i++) {\r\n        row = this.object.layer.data[i];\r\n        let higherRow = this.object.layer.data[i - 1];\r\n\r\n        if(this.collisionTiles.includes(row[0].index) != this.collisionTiles.includes(higherRow[0].index)) {\r\n            startPoint = new Phaser.Geom.Point(offset.x,  i * tileHeight + offset.y);\r\n            endPoint = new Phaser.Geom.Point(tileWidth + offset.x, i * tileHeight + offset.y);\r\n\r\n            columns[0].push(startPoint);\r\n        }\r\n\r\n        for(let j = 1, jLength = row.length; j < jLength; j++) {\r\n            let tile = row[j],\r\n                isCollisionTile = this.collisionTiles.includes(tile.index),\r\n                isCollisionHigherTile = this.collisionTiles.includes(higherRow[j].index);\r\n            \r\n            if(isCollisionTile == isCollisionHigherTile) {\r\n                if(startPoint) {\r\n                    startPoint.neighbours = [endPoint];\r\n                    endPoint.neighbours = [startPoint];\r\n\r\n                    points.push(startPoint, endPoint);\r\n                    segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\r\n\r\n                    columns[j].push(endPoint);\r\n\r\n                    startPoint = false;\r\n                    endPoint = false;\r\n                }\r\n                continue;\r\n            }\r\n    \r\n            let x = j * tileWidth + offset.x,\r\n                y = i * tileHeight + offset.y;\r\n    \r\n            if(!startPoint) {\r\n                startPoint = new Phaser.Geom.Point(x, y);\r\n\r\n                columns[j].push(startPoint);\r\n            }\r\n    \r\n            if(!endPoint) {\r\n                endPoint = new Phaser.Geom.Point(x + tileWidth, y);\r\n            }\r\n            else {\r\n                endPoint.x = x + tileWidth;\r\n            }\r\n        }\r\n    \r\n        if(startPoint) {\r\n            startPoint.neighbours = [endPoint];\r\n            endPoint.neighbours = [startPoint];\r\n\r\n            points.push(startPoint, endPoint);\r\n            segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\r\n\r\n            columns[row.length].push(endPoint);\r\n        }\r\n\r\n        startPoint = false;\r\n        endPoint = false;\r\n    }\r\n\r\n    //set bottom horizontal lines\r\n    row = this.object.layer.data.slice(-1)[0];\r\n    let y = this.object.layer.data.length * tileHeight + offset.y;\r\n\r\n    if(this.collisionTiles.includes(row[0].index)) {\r\n        startPoint = new Phaser.Geom.Point(offset.x, y);\r\n        endPoint = new Phaser.Geom.Point(tileWidth + offset.x, y);\r\n\r\n        columns[0].push(startPoint);\r\n    }\r\n\r\n    for(let i = 1, iLength = row.length; i < iLength; i++) {\r\n        let tile = row[i];\r\n        \r\n        if(!this.collisionTiles.includes(tile.index)) {\r\n            if(startPoint) {\r\n                startPoint.neighbours = [endPoint];\r\n                endPoint.neighbours = [startPoint];\r\n\r\n                points.push(startPoint, endPoint);\r\n                segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\r\n\r\n                columns[i].push(endPoint);\r\n\r\n                startPoint = false;\r\n                endPoint = false;\r\n            }\r\n            continue;\r\n        }\r\n\r\n        let x = i * tileWidth + offset.x;\r\n\r\n        if(!startPoint) {\r\n            startPoint = new Phaser.Geom.Point(x, y);\r\n\r\n            columns[i].push(startPoint);\r\n        }\r\n\r\n        if(!endPoint) {\r\n            endPoint = new Phaser.Geom.Point(x + tileWidth, y);\r\n        }\r\n        else {\r\n            endPoint.x = x + tileWidth;\r\n        }\r\n    }\r\n\r\n    if(startPoint) {\r\n        startPoint.neighbours = [endPoint];\r\n        endPoint.neighbours = [startPoint];\r\n\r\n        points.push(startPoint, endPoint);\r\n        segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\r\n\r\n        columns[row.length].push(endPoint);\r\n    }\r\n\r\n    //set vertical lines\r\n    for(let i = 0, iLength = columns.length; i < iLength; i++) {\r\n        const column = columns[i];\r\n\r\n        for(let j = 0, jLength = column.length - 1; j < jLength; j++) {\r\n            segments.push(new Phaser.Geom.Line(column[j].x, column[j].y, column[j+1].x, column[j+1].y));\r\n            column[j].neighbours.push(column[j+1]);\r\n            column[j+1].neighbours.push(column[j]);\r\n            j++;\r\n        }\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n\r\n/**\r\n* Set tile types which should be mapped (for Phaser.Tilemaps.StaticTilemapLayer and Phaser.Tilemaps.DynamicTilemapLayer maps only).\r\n*\r\n* @method Raycaster.Map#setCollisionTiles\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @since 0.7.3\r\n*\r\n* @param {array} [tiles = []] - Set of tile's indexes to map.\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function setCollisionTiles(tiles = []) {\r\n    this.collisionTiles = tiles;\r\n    return this;\r\n}\r\n", "/**\r\n * Set segment count for cirle's map.\r\n * If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\r\n *\r\n * @method Raycaster.Map#setSegmentCount\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} count - Circle map's segment count.\r\n *\r\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n */\r\nexport function setSegmentCount(count) {\r\n    this.segmentCount = count;\r\n    this.circle = count ? false : true;\r\n\r\n    this.updateMap();\r\n    return this;\r\n}\r\n", "/**\r\n * Set ray's angle (direction) in radians.\r\n *\r\n * @method Raycaster.Ray#setAngle\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} [angle = 0] - Ray's angle in radians.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setAngle(angle = 0) {\r\n    this.angle = Phaser.Math.Angle.Normalize(angle);\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's angle (direction) in degrees.\r\n *\r\n * @method Raycaster.Ray#setAngleDeg\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.1\r\n *\r\n * @param {number} [angle = 0] - Ray's angle in degrees.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setAngleDeg(angle = 0) {\r\n    this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(angle));\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    return this;\r\n}\r\n", "/**\r\n * Cast ray to find closest intersection with tested mapped objects.\r\n *\r\n * @method Raycaster.Ray#cast\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - options that may include:\r\n * @param {object[]} [options.objects = {Raycaster#mappedObjects}] - Array of game objects to test. If not provided test all mapped game objects.\r\n * @param {Phaser.Geom.Point|Point} [options.target] - Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point.\r\n * @param {boolean} [options.internal = false] - Flag determining if method is used by other casting method.\r\n *\r\n * @return {(Phaser.Geom.Point|boolean)} Ray's closest intersection with tested objects. Returns false if no intersection has been found. Additionally contains reference to hit mapped object and segment if available.\r\n */\r\nexport function cast(options = {}) {\r\n    let closestIntersection;\r\n    let closestSegment;\r\n    let closestObject;\r\n    let closestDistance = this.rayRange;\r\n    let internal = options.internal ? options.internal : false;\r\n    let startTime = performance.now();\r\n    let stats = {\r\n        method: 'cast',\r\n        rays: 1,\r\n        testedMappedObjects: 0,\r\n        hitMappedObjects: 0,\r\n        segments: 0,\r\n        time: 0\r\n    };\r\n\r\n    //if bounding box is defined check bounding box intersection\r\n    if(this._raycaster && this._raycaster.boundingBox) {\r\n        let intersections = [];\r\n        Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\r\n        if(intersections.length === 1)\r\n            closestIntersection = intersections[0];\r\n        else if(intersections.length > 1) {\r\n            for(let intersection of intersections) {\r\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n                if(distance < closestDistance) {\r\n                    closestDistance = distance;\r\n                    closestIntersection = intersection;\r\n                }\r\n            }\r\n        }\r\n        //if ray target is declared\r\n        else if(options.target){\r\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\r\n            //if target is within ray range\r\n            if(this.rayRange > distance) {\r\n                closestDistance = distance;\r\n                closestIntersection = options.target;\r\n            }\r\n        }\r\n    }\r\n\r\n    //if no objects to cast ray were passed, use raycasters mapped objects\r\n    if(!options.objects) {\r\n        if(this._raycaster)\r\n            options.objects = this._raycaster.mappedObjects;\r\n        else\r\n            return intersections;\r\n    }\r\n    \r\n    for(let object of options.objects) {\r\n        let map, boundingBox, boundingBoxIntersections = [], canTestMap = false;\r\n        \r\n        if(object.type === 'body' || object.type === 'composite')\r\n            map = object.raycasterMap;\r\n        else\r\n            map = object.data.get('raycasterMap');\r\n\r\n        stats.testedMappedObjects++;\r\n\r\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\r\n        if(internal) {\r\n            boundingBox = map._boundingBox;\r\n        }\r\n        else {\r\n            boundingBox = map.getBoundingBox();\r\n            boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\r\n        }\r\n\r\n        //check if object is intersected by ray\r\n        if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray, boundingBox, boundingBoxIntersections).length === 0)\r\n            continue;\r\n\r\n        //check if bounding box is closer than closest intersection\r\n        if(Phaser.Geom.Rectangle.ContainsPoint(boundingBox, this.origin)) {\r\n            canTestMap = true;\r\n        }\r\n        else {\r\n            for(let boundingBoxIntersection of boundingBoxIntersections) {\r\n                if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, boundingBoxIntersection.x, boundingBoxIntersection.y) < closestDistance) {\r\n                    canTestMap = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(!canTestMap)\r\n            continue;\r\n\r\n        stats.hitMappedObjects++;\r\n        stats.segments += map.getSegments(this).length;\r\n        \r\n        //check intersections\r\n        for(let segment of map.getSegments(this)) {\r\n            let intersection = [];\r\n\r\n            //if target point is segmemt point\r\n            if(options.target) {\r\n                if(\r\n                    Phaser.Geom.Point.Equals(options.target, segment.getPointA())\r\n                    || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\r\n                ) {\r\n                    intersection = options.target;\r\n                }\r\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\r\n                    continue;\r\n            }\r\n            //if no intersection continue\r\n            else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\r\n              continue;\r\n            \r\n            //get closest intersection\r\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n            if(distance < closestDistance) {\r\n                closestDistance = distance;\r\n                closestIntersection = intersection;\r\n                closestObject = map.object;\r\n                closestSegment = segment;\r\n            }\r\n        }\r\n\r\n        //check if map is circular\r\n        if(map.circle) {\r\n           //if circular map has generated points (besides tangent points to ray)\r\n            if(map._points.length > 0) {\r\n                continue;\r\n            }\r\n            \r\n            //check if target point is a circle tangent point to ray\r\n            if(options.target) {\r\n                let points = map.getPoints(this);\r\n                let isTangent = false;\r\n                for(let point of points) {\r\n                    if(Phaser.Geom.Point.Equals(options.target, point)) {\r\n                        //get closest intersection\r\n                        let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n\r\n                        if(distance < closestDistance) {\r\n                            closestDistance = distance;\r\n                            closestIntersection = point;\r\n                            closestObject = map.object;\r\n                            isTangent = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if(isTangent)\r\n                    continue;\r\n            }\r\n\r\n            let circleIntersections = [];\r\n            let offset = new Phaser.Geom.Point();\r\n            offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\r\n            offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\r\n\r\n            //calculate circle's center after rotation\r\n            let rotation = map.object.rotation;\r\n            if(rotation !== 0) {\r\n                let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\r\n                Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                let cB = vector.getPointB();\r\n                offset.x = cB.x;\r\n                offset.y = cB.y;\r\n            }\r\n\r\n            //create transformed circle\r\n            let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\r\n\r\n            if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\r\n                for(let intersection of circleIntersections) {\r\n                    //get closest intersection\r\n                    let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\r\n\r\n                    if(distance < closestDistance) {\r\n\r\n                        closestDistance = distance;\r\n                        closestIntersection = intersection;\r\n                        closestObject = map.object;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //check container map's circles\r\n        if(map.type == 'Container' && map._circles.length > 0) {\r\n            for(let circle of map._circles) {\r\n                //check if target point is a circle tangent point to ray\r\n                if(options.target) {\r\n                    let isTangent = false;\r\n\r\n                    for(let point of circle.points) {\r\n                        if(Phaser.Geom.Point.Equals(options.target, point)) {\r\n                            //get closest intersection\r\n                            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n\r\n                            if(distance < closestDistance) {\r\n                                closestDistance = distance;\r\n                                closestIntersection = point;\r\n                                closestObject = map.object;\r\n                                isTangent = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(isTangent)\r\n                        continue;\r\n                }\r\n\r\n                let circleIntersections = [];\r\n\r\n                if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\r\n                    for(let intersection of circleIntersections) {\r\n                        //get closest intersection\r\n                        let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\r\n\r\n                        if(distance < closestDistance) {\r\n                            closestDistance = distance;\r\n                            closestIntersection = intersection;\r\n                            closestObject = map.object;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //update stats\r\n    if(internal) {\r\n        this._stats.rays++;\r\n        this._stats.testedMappedObjects += stats.testedMappedObjects;\r\n        this._stats.hitMappedObjects += stats.hitMappedObjects;\r\n        this._stats.segments += stats.segments;\r\n    }\r\n    else {\r\n        stats.time = performance.now() - startTime;\r\n        this._stats = stats;\r\n    }\r\n\r\n    let result;\r\n    if(!closestIntersection) {\r\n        if(this.ignoreNotIntersectedRays)\r\n            return false;\r\n\r\n        result = this._ray.getPointB();\r\n    }\r\n    else {\r\n        result = new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\r\n        result.segment = closestSegment;\r\n        result.object = closestObject;\r\n    }\r\n\r\n    if(this.round) {\r\n        result.x = Math.round(result.x);\r\n        result.y = Math.round(result.y);\r\n    }\r\n\r\n    if(!internal)\r\n        this.drawDebug([result]);\r\n    \r\n    return result;\r\n}", "/**\r\n * Cast ray in all directions to find closest intersections with tested mapped objects.\r\n *\r\n * @method Raycaster.Ray#castCircle\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - options that may include:\r\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\r\n *\r\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\r\n */\r\nexport function castCircle(options = {}) {\r\n    let originalAngle = this.angle;\r\n    let intersections = [];\r\n    let maps = [];\r\n    let rayTargets = [];\r\n    let testedObjects = [];\r\n    let startTime = performance.now();\r\n    //reset stats\r\n    this._stats = {\r\n        method: 'castCircle',\r\n        rays: 0,\r\n        testedMappedObjects: 0,\r\n        hitMappedObjects: 0,\r\n        segments: 0,\r\n        time: 0\r\n    };\r\n\r\n    //if no objects to cast ray were passed, use raycasters mapped objects\r\n    if(!options.objects) {\r\n        if(this._raycaster)\r\n            options.objects = this._raycaster.mappedObjects;\r\n        else\r\n            return intersections;\r\n    }\r\n\r\n    //if bounding box is defined add bounding box points to \r\n    if(this._raycaster && this._raycaster.boundingBox) {\r\n        for(let point of this._raycaster.boundingBox.points) {\r\n            rayTargets.push({\r\n                point: point,\r\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\r\n            });\r\n        }\r\n    }\r\n\r\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\r\n        let object = options.objects[i];\r\n        //if bound in range\r\n        if(!this.boundsInRange(object))\r\n            continue;\r\n        \r\n        testedObjects.push(object);\r\n\r\n        let map, boundingBox;\r\n        if(object.type === 'body' || object.type === 'composite')\r\n            map = object.raycasterMap;\r\n        else\r\n            map = object.data.get('raycasterMap');\r\n\r\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\r\n        boundingBox = map.getBoundingBox();\r\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\r\n\r\n        map._boundingBox = boundingBox;\r\n\r\n        maps.push(map);\r\n        //get points and angles\r\n        for(let point of map.getPoints(this)) {\r\n            rayTargets.push({\r\n                point: point,\r\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\r\n            });\r\n        }\r\n\r\n        //get objects intersections\r\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\r\n            let objectB = options.objects[j];\r\n            let mapB;\r\n            if(objectB.type === 'body' || objectB.type === 'composite')\r\n                mapB = objectB.raycasterMap;\r\n            else {\r\n                mapB = objectB.data.get('raycasterMap');\r\n            }\r\n            //check if bounding boxes overlap\r\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\r\n                continue;\r\n            \r\n            //find objects intersections\r\n            for(let segmentA of map.getSegments(this)) {\r\n                for(let segmentB of mapB.getSegments(this)) {\r\n                    let intersection = [];\r\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                        continue;\r\n                    \r\n                    let target = {\r\n                        point: new Phaser.Geom.Point(intersection.x, intersection.y),\r\n                        angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\r\n                    };\r\n                    target.point.intersection = false;\r\n                    rayTargets.push(target);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //sort target points by angle\r\n    rayTargets.sort(function(a, b){\r\n        //if rays towards points have the same angles promote closer one\r\n        if(a.angle == b.angle) {\r\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\r\n                return 1;\r\n            else\r\n                return -1;\r\n        }\r\n\r\n        return a.angle - b.angle;\r\n    }.bind(this));\r\n\r\n    let previousTarget = {\r\n        angle: false\r\n    };\r\n\r\n    //cast rays\r\n    for(let target of rayTargets){\r\n        //if current target is the same as previous one skip loop\r\n        if(target.angle === previousTarget.angle) {\r\n            continue;\r\n        }\r\n\r\n        previousTarget = target;\r\n\r\n        this.setAngle(target.angle);\r\n        let intersection = this.cast({\r\n            objects: testedObjects,\r\n            target: target.point,\r\n            internal: true\r\n        });\r\n\r\n        if(intersection) {\r\n            //if intersection hits target point check if ray \"glanced\" mapped object.\r\n            let castSides = false;\r\n            if(this.round) {\r\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\r\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\r\n            }\r\n            else {\r\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\r\n            }\r\n\r\n            if(!castSides) {\r\n                //castSides = false;\r\n            }\r\n            else if(!target.point.neighbours || target.point.neighbours.length < 2) {\r\n                //castSides = true;\r\n            }\r\n            //check if ray and at least one line between target point and it's neighbours are parallel\r\n            else if(Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[0])) < 0.0001\r\n                || Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[1])) < 0.0001) {\r\n                //castSides = true;\r\n            }\r\n            //check if ray crossed more than 1 points of triangle created by tatget point and it's neighbours\r\n            else {\r\n                let triangleIntersections = [];\r\n                if(!target.point.neighboursTriangle) {\r\n                    target.point.neighboursTriangle = new Phaser.Geom.Triangle(target.point.x, target.point.y, target.point.neighbours[0].x, target.point.neighbours[0].y, target.point.neighbours[1].x, target.point.neighbours[1].y);\r\n                }\r\n\r\n                Phaser.Geom.Intersects.GetTriangleToLine(target.point.neighboursTriangle, this._ray, triangleIntersections);\r\n                \r\n                //if point of intersection of ray and tirangle are close to target point, assume ray \"glanced\" triangle.\r\n                for(let triangleIntersection of triangleIntersections) {\r\n                    if(Math.abs(target.point.x - triangleIntersection.x) > 0.0001 && Math.abs(target.point.y - triangleIntersection.y) > 0.0001) {\r\n                        castSides = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            //if ray \"glanced\" mapped object cast two additional rays\r\n            if(castSides) {\r\n                this.setAngle(target.angle - 0.0001);\r\n                let intersectionA = this.cast({\r\n                    objects: testedObjects,\r\n                    internal: true\r\n                });\r\n\r\n                if(intersectionA) {\r\n                    intersections.push(intersectionA);\r\n                }\r\n\r\n                intersections.push(intersection);\r\n\r\n                this.setAngle(target.angle + 0.0001);\r\n                let intersectionB = this.cast({\r\n                    objects: testedObjects,\r\n                    internal: true\r\n                });\r\n\r\n                if(intersectionB) {\r\n                    intersections.push(intersectionB);\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            intersections.push(intersection);\r\n        }\r\n    }\r\n\r\n    this.setAngle(originalAngle);\r\n    this.intersections = intersections;\r\n\r\n    if(this.autoSlice)\r\n        this.slicedIntersections = this.slice();\r\n\r\n    this._stats.time = performance.now() - startTime;\r\n\r\n    this.drawDebug(intersections);\r\n\r\n    return intersections;\r\n}\r\n", "/**\r\n * Cast ray in a cone to find closest intersections with tested mapped objects.\r\n *\r\n * @method Raycaster.Ray#castCone\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.7.0\r\n *\r\n * @param {object} [options] - options that may include:\r\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\r\n *\r\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\r\n */\r\nexport function castCone(options = {}) {\r\n    let originalAngle = this.angle;\r\n    let intersections = [];\r\n    let maps = [];\r\n    let rayTargets = [];\r\n    let testedObjects = [];\r\n    let cone = this.cone;\r\n    let minAngle = 0;\r\n    let maxAngle = 0;\r\n    let angleOffset = 0;\r\n    let startTime = performance.now();\r\n    //reset stats\r\n    this._stats = {\r\n        method: 'castCone',\r\n        rays: 0,\r\n        testedMappedObjects: 0,\r\n        hitMappedObjects: 0,\r\n        segments: 0,\r\n        time: 0\r\n    };\r\n\r\n    //set cone\r\n    if(options.cone !== undefined)\r\n        cone = options.cone;\r\n    if(options.coneDeg !== undefined)\r\n        cone = Phaser.Math.DegToRad(options.coneDeg);\r\n\r\n    //set cone min and max angle\r\n    minAngle = this.angle - cone / 2;\r\n    maxAngle = this.angle + cone / 2;\r\n\r\n    //add min and max angle points\r\n    this.setAngle(minAngle);\r\n    rayTargets.push({\r\n        point: this._ray.getPointB(),\r\n        angle: minAngle,\r\n        angleOffsetDeg: Phaser.Math.RadToDeg(-cone / 2)\r\n    });\r\n\r\n    this.setAngle(maxAngle);\r\n    rayTargets.push({\r\n        point: this._ray.getPointB(),\r\n        angle: maxAngle,\r\n        angleOffsetDeg: Phaser.Math.RadToDeg(cone / 2)\r\n    });\r\n\r\n    //if no objects to cast ray were passed, use raycasters mapped objects\r\n    if(!options.objects) {\r\n        if(this._raycaster)\r\n            options.objects = this._raycaster.mappedObjects;\r\n        else\r\n            return intersections;\r\n    }\r\n\r\n    //if bounding box is defined add bounding box points to \r\n    if(this._raycaster && this._raycaster.boundingBox) {\r\n        for(let point of this._raycaster.boundingBox.points) {\r\n\r\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\r\n\r\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\r\n                rayTargets.push({\r\n                    point: point,\r\n                    angle: angle,\r\n                    angleOffsetDeg: -angleOffsetDeg\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\r\n        let object = options.objects[i];\r\n        //if bound in range\r\n        if(!this.boundsInRange(object))\r\n            continue;\r\n        \r\n        testedObjects.push(object);\r\n\r\n        let map, boundingBox;\r\n        if(object.type === 'body' || object.type === 'composite')\r\n            map = object.raycasterMap;\r\n        else\r\n            map = object.data.get('raycasterMap');\r\n\r\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\r\n        boundingBox = map.getBoundingBox();\r\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\r\n\r\n        map._boundingBox = boundingBox;\r\n\r\n        maps.push(map);\r\n        //get points and angles\r\n        for(let point of map.getPoints(this)) {\r\n\r\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\r\n\r\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\r\n                rayTargets.push({\r\n                    point: point,\r\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y),\r\n                    angleOffsetDeg: -angleOffsetDeg\r\n                });\r\n            }\r\n        }\r\n\r\n        //get objects intersections\r\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\r\n            let objectB = options.objects[j];\r\n            let mapB;\r\n            if(objectB.type === 'body' || objectB.type === 'composite')\r\n                mapB = objectB.raycasterMap;\r\n            else\r\n                mapB = objectB.data.get('raycasterMap');\r\n            //check if bounding boxes overlap\r\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\r\n                continue;\r\n            \r\n            //find objects intersections\r\n            for(let segmentA of map.getSegments(this)) {\r\n                for(let segmentB of mapB.getSegments(this)) {\r\n                    let intersection = [];\r\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                        continue;\r\n                    let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n                    let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\r\n\r\n                    if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\r\n                        rayTargets.push({\r\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\r\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y),\r\n                            angleOffsetDeg: -angleOffsetDeg\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //sort target points by angle\r\n    rayTargets.sort(function(a, b){\r\n        //if rays towards points have the same angles promote closer one\r\n        if(a.angle == b.angle) {\r\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\r\n                return 1;\r\n            else\r\n                return -1;\r\n        }\r\n\r\n        return a.angleOffsetDeg - b.angleOffsetDeg;\r\n    }.bind(this));\r\n\r\n    let previousTarget = {\r\n        angle: false\r\n    };\r\n\r\n    //cast rays\r\n    for(let target of rayTargets){\r\n        //if current target is the same as previous one skip loop\r\n        if(target.angle === previousTarget.angle) {\r\n            continue;\r\n        }\r\n\r\n        previousTarget = target;\r\n        \r\n        this.setAngle(target.angle);\r\n        let intersection = this.cast({\r\n            objects: testedObjects,\r\n            target: target.point,\r\n            internal: true\r\n        });\r\n\r\n        if(intersection) {\r\n            //if intersection hits target point check if ray \"glanced\" mapped object.\r\n            let castSides = false;\r\n            if(this.round) {\r\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\r\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\r\n            }\r\n            else {\r\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\r\n            }\r\n            \r\n            if(!castSides) {\r\n                //castSides = false;\r\n            }\r\n            else if(!target.point.neighbours || target.point.neighbours.length < 2) {\r\n                //castSides = true;\r\n            }\r\n            //check if ray and at least one line between target point and it's neighbours are parallel\r\n            else if(Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[0])) < 0.0001\r\n                || Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[1])) < 0.0001) {\r\n                //castSides = true;\r\n            }\r\n            //check if ray crossed more than 1 points of triangle created by tatget point and it's neighbours\r\n            else {\r\n                let triangleIntersections = [];\r\n                if(!target.point.neighboursTriangle) {\r\n                    target.point.neighboursTriangle = new Phaser.Geom.Triangle(target.point.x, target.point.y, target.point.neighbours[0].x, target.point.neighbours[0].y, target.point.neighbours[1].x, target.point.neighbours[1].y);\r\n                }\r\n\r\n                Phaser.Geom.Intersects.GetTriangleToLine(target.point.neighboursTriangle, this._ray, triangleIntersections);\r\n                \r\n                //if point of intersection of ray and tirangle are close to arget point, assume ray \"glanced\" triangle.\r\n                for(let triangleIntersection of triangleIntersections) {\r\n                    if(Math.abs(target.point.x - triangleIntersection.x) > 0.0001 && Math.abs(target.point.y - triangleIntersection.y) > 0.0001) {\r\n                        castSides = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            //if ray \"glanced\" mapped object cast two additional rays\r\n            if(castSides) {\r\n                this.setAngle(target.angle - 0.0001);\r\n                let intersectionA = this.cast({\r\n                    objects: testedObjects,\r\n                    internal: true\r\n                });\r\n\r\n                if(intersectionA) {\r\n                    intersections.push(intersectionA);\r\n                }\r\n\r\n                intersections.push(intersection);\r\n\r\n                this.setAngle(target.angle + 0.0001);\r\n                let intersectionB = this.cast({\r\n                    objects: testedObjects,\r\n                    internal: true\r\n                });\r\n\r\n                if(intersectionB) {\r\n                    intersections.push(intersectionB);\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            intersections.push(intersection);\r\n        }\r\n    }\r\n\r\n    this.setAngle(originalAngle);\r\n    this.intersections = intersections;\r\n    if(this.autoSlice)\r\n        this.slicedIntersections = this.slice(intersections, false);\r\n    \r\n    this._stats.time = performance.now() - startTime;\r\n\r\n    this.drawDebug(intersections);\r\n\r\n    return intersections;\r\n}\r\n", "/**\r\n * Set ray's cone angle (width) in radians.\r\n *\r\n * @method Raycaster.Ray#setCone\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.7.0\r\n *\r\n * @param {number} [cone = 0] - Ray's cone angle in radians.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCone(cone = 0) {\r\n    this.cone = cone;\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's cone angle (width) in degrees.\r\n *\r\n * @method Raycaster.Ray#setConeDeg\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.7.0\r\n *\r\n * @param {number} [cone = 0] - Ray's cone angle in degrees.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setConeDeg(cone = 0) {\r\n    this.cone = Phaser.Math.DegToRad(cone);\r\n    return this;\r\n}\r\n", "/**\r\n * Configure ray.\r\n *\r\n * @method Raycaster.Ray#config\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Ray's congfiguration options. May include:\r\n * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\r\n * @param {number} [options.angle = 0] - Ray's angle in radians.\r\n * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\r\n * @param {number} [options.cone = 0] - Ray's cone angle in radians.\r\n * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\r\n * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\r\n * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\r\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\r\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function config(options) {\r\n    this.object = options.object;\r\n    //origin\r\n    if(options.origin !== undefined)\r\n        this.origin.setTo(options.origin.x, options.origin.y);\r\n\r\n    //angle\r\n    if(options.angle !== undefined)\r\n        this.angle = Phaser.Math.Angle.Normalize(options.angle);\r\n\r\n    //angle deg\r\n    if(options.angleDeg !== undefined)\r\n        this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(options.angleDeg));\r\n\r\n    //cone angle\r\n    if(options.cone !== undefined)\r\n        this.cone = options.cone;\r\n\r\n    //cone angle deg\r\n    if(options.coneDeg !== undefined)\r\n        this.cone = Phaser.Math.DegToRad(options.coneDeg);\r\n\r\n    //ray range (0 = max)\r\n    if(options.rayRange !== undefined)\r\n        this.rayRange = options.rayRange;\r\n\r\n    //collision range (0 = max)\r\n    if(options.collisionRange !== undefined)\r\n        this.collisionRange = options.collisionRange;\r\n\r\n    //detection range (0 = max)\r\n    if(options.detectionRange !== undefined)\r\n        this.detectionRange = options.detectionRange;\r\n\r\n    //ignore not intersected rays\r\n    if(options.ignoreNotIntersectedRays !== undefined)\r\n        this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\r\n    \r\n    //round\r\n    if(options.round !== undefined)\r\n        this.round = (options.round == true)\r\n\r\n    //auto slice\r\n    if(options.autoSlice !== undefined)\r\n        this.autoSlice = (options.autoSlice == true)\r\n\r\n    //enable physics\r\n    if(options.enablePhysics !== undefined && options.enablePhysics)\r\n        this.enablePhysics(options.enablePhysics);\r\n    \r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n\r\n    if(this._raycaster.debugOptions.enabled && this._raycaster.scene !== undefined) {\r\n        this.graphics =  this._raycaster.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n        this.graphics.setDepth(1000);\r\n    }\r\n\r\n    return this;\r\n}\r\n", "/**\r\n * Draw rays in debug mode\r\n *\r\n * @method Raycaster.Ray#drawDebug\r\n * @memberof Raycaster\r\n * @private\r\n * @since 0.10.0\r\n * \r\n * @param {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function drawDebug(intersections) {\r\n    if(this.graphics === undefined || !this._raycaster.debugOptions.enabled)\r\n        return this;\r\n\r\n    //clear\r\n    this.graphics.clear();\r\n\r\n    if(!this._raycaster.debugOptions.rays)\r\n        return this;\r\n    \r\n    if(this._raycaster.debugOptions.graphics.ray) {\r\n        this.graphics.lineStyle(1, this._raycaster.debugOptions.graphics.ray);\r\n\r\n        for(let intersection of intersections) {\r\n            this.graphics.strokeLineShape({\r\n                x1: this.origin.x,\r\n                y1: this.origin.y,\r\n                x2: intersection.x,\r\n                y2: intersection.y\r\n            });\r\n        }\r\n    }\r\n\r\n    if(this._raycaster.debugOptions.graphics.rayPoint) {\r\n        this.graphics.fillStyle(this._raycaster.debugOptions.graphics.rayPoint);\r\n\r\n        this.graphics.fillPoint(this.origin.x, this.origin.y, 3);\r\n        \r\n        for(let intersection of intersections) {\r\n            this.graphics.fillPoint(intersection.x, intersection.y, 3);\r\n        }\r\n    }\r\n\r\n    return this;\r\n}", "/**\r\n * Destroy object\r\n *\r\n * @method Raycaster.Ray#destroy\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.3\r\n */\r\n export function destroy() {\r\n    if(this.graphics)\r\n        this.graphics.destroy();\r\n\r\n    for(let key in this) {\r\n        delete this[key];\r\n    }\r\n }", "/**\r\n * Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. Physics body can be added only once.\r\n *\r\n * @method Raycaster.Ray#enablePhysics\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {'arcade'|'matter'} [type = 'arcade'] - Physics type\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function enablePhysics(type = 'arcade') {\r\n    \r\n    if(this.body !== undefined)\r\n        return this;\r\n\r\n    this.collisionCircle = this._raycaster.scene.add.circle(this.origin.x, this.origin.y, this.collisionRange);\r\n    this.collisionCircle._ray = this;\r\n\r\n    if(type === 'matter') {\r\n        this.bodyType = 'matter';\r\n\r\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\r\n            let bounds = this._raycaster.boundingBox;\r\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'rectangle', x:bounds.rectangle.centerX, y:bounds.rectangle.centerY, width:bounds.rectangle.width, height:bounds.rectangle.height }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\r\n        }\r\n        else {\r\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'circle' }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\r\n        }\r\n\r\n        this.body = this.collisionCircle.body;\r\n        this.body._ray = this;\r\n        this.setOnCollideActive();\r\n    }\r\n    else {\r\n        this.bodyType = 'arcade';\r\n        this._raycaster.scene.physics.add.existing(this.collisionCircle);\r\n\r\n        this.body = this.collisionCircle.body;\r\n        this.body\r\n            .setCircle(this.collisionRange)\r\n            .setAllowGravity(false)\r\n            .setImmovable(true);\r\n        this.body._ray = this;\r\n    }\r\n\r\n    return this;\r\n}\r\n", "/*Matter physics methods for ray body*/\r\n/**\r\n * Sets the collision category of this ray's Matter Body. This number must be a power of two between 2^0 (= 1) and 2^31.\r\n * Two bodies with different collision groups (see {@link #setCollisionGroup}) will only collide if their collision\r\n * categories are included in their collision masks (see {@link #setCollidesWith}).\r\n *\r\n * @method Raycaster.Ray#setCollisionCategory\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {number} value - Unique category bitfield.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCollisionCategory(value) {\r\n    this.body.collisionFilter.category = value;\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Sets the collision group of this ray's Matter Body. If this is zero or two Matter Bodies have different values,\r\n * they will collide according to the usual rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).\r\n * If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value,\r\n * they will never collide.\r\n *\r\n * @method Raycaster.Ray#setCollisionCategory\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {number} value - Unique group index.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCollisionGroup(value) {\r\n    this.body.collisionFilter.group = value;\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Sets the collision mask for this ray's Matter Body. Two Matter Bodies with different collision groups will only\r\n * collide if each one includes the other's category in its mask based on a bitwise AND, i.e. `(categoryA & maskB) !== 0`\r\n * and `(categoryB & maskA) !== 0` are both true.*\r\n *\r\n * @method Raycaster.Ray#setCollidesWith\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {(number|number[])} categories - A unique category bitfield, or an array of them.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\n\r\nexport function setCollidesWith(categories) {\r\n    var flags = 0;\r\n\r\n    if (!Array.isArray(categories))\r\n    {\r\n        flags = categories;\r\n    }\r\n    else\r\n    {\r\n        for (var i = 0; i < categories.length; i++)\r\n        {\r\n            flags |= categories[i];\r\n        }\r\n    }\r\n\r\n    this.body.collisionFilter.mask = flags;\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n * \r\n * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n * to the callback.\r\n *\r\n * @method Raycaster.Ray#setOnCollide\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {function} callback - The callback to invoke when this body starts colliding with another.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOnCollide(callback) {\r\n    let self = this;\r\n    this.body.onCollideCallback = function(collisionInfo) {\r\n        if(collisionInfo.rayCollided) {\r\n            callback(collisionInfo);\r\n        }\r\n        else if(self.processOverlap(collisionInfo)) {\r\n            collisionInfo.rayCollided = true;\r\n            callback(collisionInfo);\r\n        }\r\n    };\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n * \r\n * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n * to the callback.\r\n *\r\n * @method Raycaster.Ray#setOnCollideEnd\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {function} callback - The callback to invoke when this body stops colliding with another.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOnCollideEnd(callback) {\r\n    this.body.onCollideEndCallback = function(collisionInfo) {\r\n        if(collisionInfo.rayCollided) {\r\n            collisionInfo.rayCollided = false;\r\n            callback(collisionInfo);\r\n        }\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n * \r\n * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n * to the callback.\r\n *\r\n * @method Raycaster.Ray#setOnCollideActive\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {function} callback - The callback to invoke for the duration of this body colliding with another.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOnCollideActive(callback) {\r\n    let self = this;\r\n    let func = function(collisionInfo) {\r\n        if(self.processOverlap(collisionInfo)) {\r\n            let body = collisionInfo.bodyA.label === 'phaser-raycaster-ray-body' ? collisionInfo.bodyB : collisionInfo.bodyA;\r\n\r\n            if(collisionInfo.rayCollided !== true) {\r\n                collisionInfo.rayCollided = true;\r\n                if(self.body.onCollideCallback) {\r\n                    self.body.onCollideCallback(collisionInfo);\r\n                }\r\n\r\n                if(self.body.onCollideWith !== undefined && self.body.onCollideWith[body.id]) {\r\n                    self.body.onCollideWith[body.id](body, collisionInfo);\r\n                }\r\n            }\r\n            if(callback)\r\n                callback(collisionInfo);\r\n        }\r\n        else {\r\n            if(self.body.onCollideEndCallback && collisionInfo.rayCollided === true) {\r\n                self.body.onCollideEndCallback(collisionInfo);\r\n            }\r\n        }\r\n    }\r\n\r\n    this.body.onCollideActiveCallback = func;\r\n\r\n    return this;\r\n}\r\n\r\n/**\r\n * The callback is sent a reference to the other body, along with a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n * \r\n * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n * to the callback.\r\n *\r\n * @method Raycaster.Ray#setOnCollideWith\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {(MatterJS.Body|MatterJS.Body[])} body - The body, or an array of bodies, to test for collisions with.\r\n * @param {function} callback - The callback to invoke when this body collides with the given body or bodies.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOnCollideWith(body, callback) {\r\n    let self = this;\r\n    let func = function(body, collisionInfo) {\r\n        if(collisionInfo.rayCollided) {\r\n            callback(body, collisionInfo);\r\n        }\r\n        else if(self.processOverlap(collisionInfo)) {\r\n            collisionInfo.rayCollided = true;\r\n            callback(body, collisionInfo);\r\n        }\r\n    }\r\n\r\n    if (!Array.isArray(body))\r\n    {\r\n        body = [ body ];\r\n    }\r\n\r\n    for (var i = 0; i < body.length; i++)\r\n    {\r\n        var src = (body[i].hasOwnProperty('body')) ? body[i].body : body[i];\r\n\r\n        this.body.setOnCollideWith(src, func);\r\n    }\r\n\r\n    return this;\r\n};\r\n", "/**\r\n * Set ray's source position.\r\n *\r\n * @method Raycaster.Ray#setOrigin\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOrigin(x, y) {\r\n    this.origin.setTo(x, y);\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n\r\n    if(this.bodyType === 'matter' && this.collisionRange !== Phaser.Math.MAX_SAFE_INTEGER) {\r\n        this.collisionCircle.x = x;\r\n        this.collisionCircle.y = y;\r\n    }\r\n    else if(this.bodyType === 'arcade') {\r\n        this.collisionCircle.x = x;\r\n        this.collisionCircle.y = y;\r\n    }\r\n\r\n    return this;\r\n}\r\n", "/**\r\n * Get game objects overlaping field of view.\r\n *\r\n * @method Raycaster.Ray#overlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {object|object[]} [objects] - Game object / array off game objects to test.\r\n *\r\n * @return {object[]} Array of game objects that overlaps with field of view.\r\n */\r\nexport function overlap(objects) {\r\n    let targets = [];\r\n    let overlapCircle = new Phaser.Geom.Circle(this.origin.x, this.origin.y, this.collisionRange);\r\n\r\n    //matter physics\r\n    if(this.bodyType === 'matter') {\r\n        let isCollisionInfo = false;\r\n        if(objects === undefined) {\r\n            objects = this._raycaster.scene.matter.query.collides(this.body, this._raycaster.scene.matter.getMatterBodies());\r\n\r\n            for(let object of objects) {   \r\n                let body = object.bodyA === this.body ? object.bodyB : object.bodyA;\r\n\r\n                if(this.testMatterOverlap(body))\r\n                    targets.push(body);\r\n            }\r\n        }\r\n        //get object's body\r\n        else {\r\n            if(!Array.isArray(objects))\r\n                objects = [objects];\r\n            \r\n            for(let object of objects) {\r\n                if(object === this.body)\r\n                    continue;\r\n    \r\n                if(this.testMatterOverlap(object))\r\n                    targets.push(object);\r\n            }\r\n        }\r\n    }\r\n    //arcade physics\r\n    else {\r\n        let bodies = false;\r\n        //get bodies in range\r\n        if(objects === undefined) {\r\n            objects = this._raycaster.scene.physics.overlapCirc(this.origin.x, this.origin.y, this.collisionRange, true, true);\r\n            bodies = true;\r\n        }\r\n        //get object's body\r\n        else if(!Array.isArray(objects)) {\r\n            objects = [objects];\r\n        }\r\n        //if objects are bodies\r\n        if(bodies) {\r\n            for(let body of objects) {\r\n                if(body === this.body)\r\n                    continue;\r\n            \r\n                let hitbox;\r\n                //get physics body hitbox\r\n                if(body.isCircle) {\r\n                    hitbox = new Phaser.Geom.Circle(body.position.x + body.halfWidth, body.position.y + body.halfWidth, body.halfWidth);\r\n                }\r\n                else {\r\n                    hitbox = new Phaser.Geom.Rectangle(body.x, body.y, body.width, body.height);\r\n                }\r\n\r\n                if(this.testArcadeOverlap(hitbox))\r\n                    targets.push(body.gameObject);\r\n            }\r\n        }\r\n        //if objects are game objects\r\n        else {\r\n            for(let object of objects) {\r\n                if(object.body === undefined)\r\n                    continue;\r\n\r\n                let hitbox;\r\n                //get physics body hitbox\r\n                if(object.body.isCircle) {\r\n                    hitbox = new Phaser.Geom.Circle(object.body.position.x + object.body.halfWidth, object.body.position.y + object.body.halfWidth, object.body.halfWidth);\r\n                    if(!Phaser.Geom.Intersects.CircleToCircle(overlapCircle, hitbox))\r\n                        continue;\r\n                }\r\n                else {\r\n                    hitbox = new Phaser.Geom.Rectangle(object.body.x, object.body.y, object.body.width, object.body.height);\r\n                    if(!Phaser.Geom.Intersects.CircleToRectangle(overlapCircle, hitbox))\r\n                        continue;\r\n                }\r\n\r\n                if(this.testArcadeOverlap(hitbox))\r\n                    targets.push(object);\r\n            }\r\n        }\r\n    }\r\n\r\n    return targets;\r\n}\r\n\r\n/**\r\n * Process callback for physics collider / overlap.\r\n *\r\n * @method Raycaster.Ray#processOverlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {object} object1 - Game object or matter body passed by collider / overlap or matter CollisionInfo object.\r\n * @param {object} object2 - Game object or matter body passed by collider / overlap. Ignored if matter CollisionInfo object was passed as first argument.\r\n *\r\n * @return {boolean} Return true if game object is overlapping ray's field of view.\r\n */\r\nexport function processOverlap(object1, object2) {\r\n    let obj1, obj2, target;\r\n    //check if it's matter collisionInfo object\r\n    if(object1.bodyA !== undefined && object1.bodyB !== undefined) {\r\n        obj1 = object1.bodyA;\r\n        obj2 = object1.bodyB;\r\n    }\r\n    else {\r\n        obj1 = object1;\r\n        obj2 = object2;\r\n    }\r\n\r\n    if(obj1._ray !== undefined && obj1._ray === this)\r\n        target = obj2;\r\n    else if(obj2._ray !== undefined && obj2._ray === this)\r\n        target = obj1;\r\n    else\r\n        return false;\r\n\r\n    return (this.overlap(target).length > 0);\r\n}   \r\n\r\n/**\r\n * Test if hitbox overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\r\n *\r\n * @method Raycaster.Ray#testArcadeOverlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @private\r\n * @since 0.8.0\r\n *\r\n * @param {object} hitbox - Game object's hitbox generated inside {@link Raycaster.Ray#overlap Ray.overlap}.\r\n *\r\n * @return {boolean} True if hitbox overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\r\n */\r\nexport function testArcadeOverlap(hitbox) {\r\n    let overlap = false;\r\n\r\n    //iterate through field of view slices to check collisions with target\r\n    for(let slice of this.slicedIntersections) {\r\n        //if hitbox is a circle\r\n        if(hitbox.type == 0) {\r\n            overlap = Phaser.Geom.Intersects.TriangleToCircle(slice, hitbox);\r\n        }\r\n        //if hitbox is a rectangle\r\n        else {\r\n            overlap = Phaser.Geom.Intersects.RectangleToTriangle(hitbox, slice);\r\n        }\r\n\r\n        if(overlap) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Test if matter body overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\r\n *\r\n * @method Raycaster.Ray#testMatterOverlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @private\r\n * @since 0.9.0\r\n *\r\n * @param {object} body - Matter body.\r\n *\r\n * @return {boolean} True if body overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\r\n */\r\nexport function testMatterOverlap(object) {\r\n    let body;\r\n\r\n    if(object.type === 'body')\r\n        body = object;\r\n    else if(object.body !== undefined)\r\n        body = object.body;\r\n    else\r\n        return false;\r\n\r\n    //if body is concave, ignore convex body\r\n    let parts = body.parts.length > 1 ? body.parts.splice(1) : body.parts;\r\n    //iterate through bodies\r\n    for(let part of parts) {\r\n        let pointA = part.vertices[0];\r\n\r\n        for(let i = 1, length = part.vertices.length; i < length; i++) {\r\n            let pointB = part.vertices[i];\r\n            let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\r\n\r\n            //iterate through field of view slices to check collisions with target\r\n            for(let slice of this.slicedIntersections) {\r\n                let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\r\n                //additional checking if slice contain segment's points due to TriangleToLine bug.\r\n                if(!overlap)\r\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointA());\r\n                if(!overlap)\r\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointB());\r\n\r\n                if(overlap) {\r\n                    return true;\r\n                }\r\n            }\r\n            pointA = pointB;\r\n        }\r\n\r\n        //closing segment\r\n        let segment = new Phaser.Geom.Line(part.vertices[part.vertices.length - 1].x, part.vertices[part.vertices.length - 1].y, part.vertices[0].x, part.vertices[0].y);\r\n         //iterate through field of view slices to check collisions with target\r\n        for(let slice of this.slicedIntersections) {\r\n            let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\r\n\r\n            if(overlap) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n", "/**\r\n * Set ray's range.\r\n *\r\n * @method Raycaster.Ray#setRayRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} [rayRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setRayRange(rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\r\n    this.rayRange = rayRange;\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's maximum detection range. Objects outside detection range won't be tested.\r\n * Ray tests all objects when set to 0.\r\n *\r\n * @method Raycaster.Ray#setDetectionRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} [detectionRange = 0] - Maximum distance between ray's position and tested objects bounding boxes.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setDetectionRange(detectionRange = 0) {\r\n    this.detectionRange = detectionRange;\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's field of view maximum collision range. Objects outside collision range won't be tested by {@link Raycaster.Ray#overlap Raycaster.Ray.overlap} method.\r\n * Determines ray's physics body radius.\r\n *\r\n * @method Raycaster.Ray#setCollisionRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {number} [collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's collision range and physics body radius.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCollisionRange(collisionRange = Phaser.Math.MAX_SAFE_INTEGER) {\r\n    let oldRangeMax = this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER;\r\n    this.collisionRange = collisionRange;\r\n    this.collisionCircle.setRadius(this.collisionRange);\r\n\r\n    if(this.bodyType === 'matter') {\r\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\r\n            let bounds = this._raycaster.boundingBox;\r\n\r\n            this._raycaster.scene.matter.body.set(this.body, {\r\n                shape: {\r\n                    type: 'rectangle',\r\n                    x: bounds.rectangle.centerX,\r\n                    y: bounds.rectangle.centerY,\r\n                    width: bounds.rectangle.width,\r\n                    height: bounds.rectangle.height,\r\n                    circleRadius:0\r\n                }\r\n            });\r\n        }\r\n        else if(oldRangeMax) {\r\n            this._raycaster.scene.matter.body.set(this.body, {\r\n                shape: {\r\n                    type: 'circle',\r\n                    x: this.collisionCircle.x,\r\n                    y: this.collisionCircle.y\r\n                },\r\n                circleRadius: this.collisionRange,\r\n                isStatic: false\r\n            });\r\n        }\r\n        else {\r\n            this.collisionCircle.setRadius(this.collisionRange);\r\n        }\r\n        this._raycaster.scene.matter.body.set(this.body, 'circleRadius', this.collisionRange)\r\n    }\r\n    else if(this.bodyType === 'arcade') {\r\n        this.body.setCircle(this.collisionRange);\r\n    }\r\n\r\n    return this;\r\n}\r\n\r\n/**\r\n * Test if object's bounding box is in ray's detection range.\r\n *\r\n * @method Raycaster.Ray#boundsInRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} object - Tested object\r\n * @param {(Phaser.Geom.Rectangle|boolean)} [bounds = false] - Tested object's bounds. If not passed bounds will be generated automatically.\r\n *\r\n * @return {boolean} Information if object is in ray's detection range.\r\n */\r\nexport function boundsInRange(object, bounds = false) {\r\n    if(!this.detectionRange)\r\n        return true;\r\n\r\n    let objectBounds;\r\n    if(bounds)\r\n        objectBounds = bounds;\r\n    else {\r\n        if(object.type === 'body' || object.type === 'composite')\r\n            objectBounds = object.raycasterMap.getBoundingBox();\r\n        else\r\n            objectBounds = object.data.get('raycasterMap').getBoundingBox();\r\n    }\r\n\r\n    if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\r\n        return true;\r\n\r\n    return false;\r\n}\r\n", "/**\r\n * @classdesc\r\n *\r\n * Ray class responsible for casting ray's and testing their collisions with mapped objects.\r\n *\r\n * @namespace Raycaster.Ray\r\n * @class Raycaster.Ray\r\n * @constructor\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Ray's congfiguration options. May include:\r\n * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\r\n * @param {number} [options.angle = 0] - Ray's angle in radians.\r\n * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\r\n * @param {number} [options.cone = 0] - Ray's cone angle in radians.\r\n * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\r\n * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\r\n * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\r\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\r\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\r\n * @param {Raycaster} [raycaster] - Parent raycaster object.\r\n */\r\nexport function Ray(options, raycaster) {\r\n    /**\r\n    * Reference to parent Raycaster object.\r\n    *\r\n    * @name Raycaster.Ray#_raycaster\r\n    * @type {Raycaster}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._raycaster = raycaster ? raycaster : false;\r\n    /**\r\n    * Ray's source position.\r\n    *\r\n    * @name Raycaster.Ray#origin\r\n    * @type {Phaser.Geom.Point}\r\n    * @since 0.6.0\r\n    */\r\n    this.origin = new Phaser.Geom.Point();\r\n    /**\r\n    * Ray's representation used to calculating intersections.\r\n    *\r\n    * @name Raycaster.Ray#_ray\r\n    * @type {Phaser.Geom.Line}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._ray = new Phaser.Geom.Line();\r\n    /**\r\n    * Ray's angle in radians.\r\n    *\r\n    * @name Raycaster.Ray#angle\r\n    * @type {number}\r\n    * @default 0\r\n    * @since 0.6.0\r\n    */\r\n    this.angle = 0;\r\n    /**\r\n    * Ray's cone width angle in radians.\r\n    *\r\n    * @name Raycaster.Ray#cone\r\n    * @type {number}\r\n    * @default 0\r\n    * @since 0.7.0\r\n    */\r\n    this.cone = 0;\r\n    /**\r\n    * Ray's maximum range\r\n    *\r\n    * @name Raycaster.Ray#rayRange\r\n    * @type {number}\r\n    * @default Phaser.Math.MAX_SAFE_INTEGER\r\n    * @since 0.6.0\r\n    */\r\n    this.rayRange = Phaser.Math.MAX_SAFE_INTEGER;\r\n    /**\r\n    * Ray's maximum detection range. Objects outside detection range won't be tested.\r\n    * Ray tests all objects when set to 0.\r\n    *\r\n    * @name Raycaster.Ray#detectionRange\r\n    * @type {number}\r\n    * @default\r\n    * @since 0.6.0\r\n    */\r\n    this.detectionRange = 0;\r\n    /**\r\n    * Ray's representation of detection range used in calculating if objects are in range.\r\n    *\r\n    * @name Raycaster.Ray#detectionRangeCircle\r\n    * @type {Phaser.Geom.Circle}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\r\n    /**\r\n    * Ray's maximum collision range of ray's field of view. Radius of {@link Raycaster.Ray#collisionRangeCircle Ray.body}.\r\n    *\r\n    * @name Raycaster.Ray#collisionRange\r\n    * @type {number}\r\n    * @default Phaser.Math.MAX_SAFE_INTEGER\r\n    * @since 0.8.0\r\n    */\r\n    this.collisionRange = Phaser.Math.MAX_SAFE_INTEGER;\r\n    /**\r\n    * If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n    *\r\n    * @name Raycaster.Ray#ignoreNotIntersectedRays\r\n    * @type {boolean}\r\n    * @default true\r\n    * @since 0.6.0\r\n    */\r\n    this.ignoreNotIntersectedRays = true;\r\n    /**\r\n    * If set true, ray's hit points will be rounded.\r\n    *\r\n    * @name Raycaster.Ray#round\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.8.1\r\n    */\r\n    this.round = false;\r\n    /**\r\n    * If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n    *\r\n    * @name Raycaster.Ray#autoSlice\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.8.0\r\n    */\r\n    this.autoSlice = false;\r\n    /**\r\n    * Array of intersections from last raycast representing field of view.\r\n    *\r\n    * @name Raycaster.Ray#intersections\r\n    * @type {object[]}\r\n    * @default []\r\n    * @since 0.8.0\r\n    */\r\n    this.intersections = [];\r\n    /**\r\n    * Array of triangles representing slices of field of view from last raycast.\r\n    *\r\n    * @name Raycaster.Ray#slicedIntersections\r\n    * @type {Phaser.Geom.Triangle[]}\r\n    * @default []\r\n    * @since 0.8.0\r\n    */\r\n    this.slicedIntersections = [];\r\n\r\n    /**\r\n    * Physics body for testing field of view collisions.\r\n    *\r\n    * @name Raycaster.Ray#body\r\n    * @type {object}\r\n    * @default undefined\r\n    * @since 0.8.0\r\n    */\r\n    //this.body = false;\r\n    /**\r\n    * Physics body type.\r\n    *\r\n    * @name Raycaster.Ray#bodyType\r\n    * @type {(boolean|'arcade'|'matter')}\r\n    * @default false\r\n    * @since 0.9.0\r\n    */\r\n    this.bodyType = false;\r\n\r\n    /**\r\n    * Ray casting stats.\r\n    *\r\n    * @name Raycaster.Ray#_stats\r\n    * @type {object}\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @property {string} method Used casting method (cast, castCircle, castCone).\r\n    * @property {number} rays Casted rays.\r\n    * @property {number} testedMappedObjects Tested mapped objects.\r\n    * @property {number} hitMappedObjects Hit mapped objects.\r\n    * @property {number} segments Tested segments.\r\n    * @property {number} time Casting time.\r\n    */\r\n    this._stats = {\r\n        method: 'cast',\r\n        rays: 0,\r\n        testedMappedObjects: 0,\r\n        hitMappedObjects: 0,\r\n        segments: 0,\r\n        time: 0\r\n    };\r\n\r\n    /**\r\n    * Ray's graphics object used for debug\r\n    *\r\n    * @name Raycaster.Ray#graphics\r\n    * @type {Phaser.GameObjects.Graphics}\r\n    * @private\r\n    * @since 0.10.0\r\n    */\r\n     this.graphics;\r\n\r\n    this.config(options);\r\n};\r\n\r\nRay.prototype = {\r\n    config: require('./config.js').config,\r\n    getStats: require('./stats.js').getStats,\r\n    setRay: require('./ray.js').setRay,    \r\n    setOrigin: require('./origin.js').setOrigin,\r\n    setRayRange: require('./range.js').setRayRange,\r\n    setAngle: require('./angle.js').setAngle,\r\n    setAngleDeg: require('./angle.js').setAngleDeg,\r\n    setCone: require('./cone.js').setCone,\r\n    setConeDeg: require('./cone.js').setConeDeg,\r\n    setDetectionRange: require('./range.js').setDetectionRange,\r\n    boundsInRange: require('./range.js').boundsInRange,\r\n    cast: require('./cast.js').cast,\r\n    castCircle: require('./castCircle.js').castCircle,\r\n    castCone: require('./castCone.js').castCone,\r\n    slice: require('./slice.js').slice,\r\n    setCollisionRange: require('./range.js').setCollisionRange,\r\n    enablePhysics: require('./enablePhysics.js').enablePhysics,\r\n    overlap: require('./overlap.js').overlap,\r\n    processOverlap: require('./overlap.js').processOverlap,\r\n    testArcadeOverlap: require('./overlap.js').testArcadeOverlap,\r\n    testMatterOverlap: require('./overlap.js').testMatterOverlap,\r\n    setCollisionCategory: require('./matter-physics-methods.js').setCollisionCategory,\r\n    setCollisionGroup: require('./matter-physics-methods.js').setCollisionGroup,\r\n    setCollidesWith: require('./matter-physics-methods.js').setCollidesWith,\r\n    setOnCollide: require('./matter-physics-methods.js').setOnCollide,\r\n    setOnCollideEnd: require('./matter-physics-methods.js').setOnCollideEnd,\r\n    setOnCollideActive: require('./matter-physics-methods.js').setOnCollideActive,\r\n    setOnCollideWith: require('./matter-physics-methods.js').setOnCollideWith,\r\n    drawDebug: require('./debug.js').drawDebug,\r\n    destroy: require('./destroy.js').destroy,\r\n};\r\n", "/**\r\n * Set ray's position, direction (angle) and range.\r\n *\r\n * @method Raycaster.Ray#setRay\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} [angle] - Ray's angle in radians.\r\n * @param {number} [range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setRay(x, y, angle, rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\r\n    this.origin.setTo(x, y);\r\n    this.angle = Phaser.Math.Angle.Normalize(angle);\r\n    this.rayRange = rayRange;\r\n\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange);\r\n    return this;\r\n}\r\n", "/**\r\n * Slice ray's field of view represented by polygon or array of points into array of triangles.\r\n *\r\n * @method Raycaster.Ray#slice\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {(object[]|Phaser.Geom.Polygon)} [fov = {Ray#fov}] - Array of points or polygon representing field of view. If not passed, filed of view from last raycaste will be used.\r\n * @param {boolean} [closed = true|{Ray#fov}] - Define if field of view polygon is closed (first and last vertices sholud be connected). If fov was not passed, value depends of last type of casting.\r\n *\r\n * @return {Phaser.Geom.Triangle[]} Array of triangles representing slices of field of view.\r\n */\r\nexport function slice(intersections = this.intersections, closed = true) {\r\n    //if intersections is Phaser.Geom.Polygon object\r\n    if(!Array.isArray(intersections)) {\r\n        if(intersections.type === 4)\r\n            intersections = intersections.points;\r\n        else\r\n            return [];\r\n    }\r\n\r\n    if(intersections.length === 0)\r\n        return [];\r\n\r\n    let slices = [];\r\n    for(let i = 0, iLength = intersections.length - 1; i < iLength; i++) {\r\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[i].x, intersections[i].y, intersections[i+1].x, intersections[i+1].y));\r\n    }\r\n\r\n    if(closed)\r\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[0].x, intersections[0].y, intersections[intersections.length-1].x, intersections[intersections.length-1].y));\r\n\r\n    return slices;\r\n}\r\n", "/**\r\n * Get ray statistics for last casting. Stats include\r\n * * number of casted rays,\r\n * * number of tested mapped objects,\r\n * * number of tested map segments.\r\n * * casting time\r\n *\r\n * @method Raycaster.Ray#getStats\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.0\r\n *\r\n * @return {object} Statisticss from last casting.\r\n */\r\n export function getStats() {\r\n     return this._stats;\r\n }\r\n", "/**\r\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\r\n* @copyright    2023 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * Raycaster class responsible for creating ray objects and managing mapped objects.\r\n * \r\n * @namespace Raycaster\r\n * @class Raycaster\r\n * @constructor\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Raycaster's configuration options. May include:\r\n * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\r\n * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. If not passed, {@link Raycaster Raycaster} will set it's bounding box based on Arcade Physics / Matter physics world bounds.\r\n * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\r\n * @param {boolean|object} [options.debug] - Enable debug mode or configure it {@link Raycaster#debugOptions debugOptions}.\r\n */\r\nexport function Raycaster(options) {\r\n    /**\r\n    * Plugin version.\r\n    *\r\n    * @name Raycaster#version\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.version = '0.10.11';\r\n    /**\r\n    * Raycaster's scene\r\n    *\r\n    * @name Raycaster#scene\r\n    * @type {Phaser.Scene}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.scene;\r\n    /**\r\n    * Raycaster's graphics object used for debug\r\n    *\r\n    * @name Raycaster#graphics\r\n    * @type {Phaser.GameObjects.Graphics}\r\n    * @private\r\n    * @since 0.10.0\r\n    */\r\n    this.graphics;\r\n    /**\r\n    * Raycaster's debug config\r\n    *\r\n    * @name Raycaster#debugOptions\r\n    * @type {Object}\r\n    * @since 0.10.0\r\n    * \r\n    * @property {boolean} [enable = false] Enable debug mode\r\n    * @property {boolean} [maps = true] - Enable maps debug\r\n    * @param {boolean} [rays = true] - Enable rays debug\r\n    * @property {boolean} graphics - Debug graphics options\r\n    * @property {boolean|number} [graphics.ray = 0x00ff00] - Debug ray color. Set false to disable.\r\n    * @property {boolean|number} [graphics.rayPoint = 0xff00ff] - Debug ray point color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapPoint = 0x00ffff] - debug map point color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapSegment = 0x0000ff] - Debug map segment color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapBoundingBox = 0xff0000] - Debug map bounding box color. Set false to disable.\r\n    */\r\n    this.debugOptions = {\r\n        enabled: false,\r\n        maps: true,\r\n        rays: true,\r\n        graphics: {\r\n            ray: 0x00ff00,\r\n            rayPoint: 0xff00ff,\r\n            mapPoint: 0x00ffff,\r\n            mapSegment: 0x0000ff,\r\n            mapBoundingBox: 0xff0000\r\n        }\r\n    };\r\n\r\n    /**\r\n    * Raycaster statistics.\r\n    *\r\n    * @name Raycaster.Raycaster#_stats\r\n    * @type {object}\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @property {object} mappedObjects Mapped objects statistics.\r\n    * @property {number} mappedObjects.total Mapped objects total.\r\n    * @property {number} mappedObjects.static Static maps.\r\n    * @property {number} mappedObjects.dynamic Dynamic maps.\r\n    * @property {number} mappedObjects.rectangleMaps Rectangle maps.\r\n    * @property {number} mappedObjects.polygonMaps Polygon maps.\r\n    * @property {number} mappedObjects.circleMaps Circle maps.\r\n    * @property {number} mappedObjects.lineMaps Line maps.\r\n    * @property {number} mappedObjects.containerMaps Container maps.\r\n    * @property {number} mappedObjects.tilemapMaps Tilemap maps.\r\n    * @property {number} mappedObjects.matterMaps Matter body maps.\r\n    */\r\n     this._stats = {\r\n        mappedObjects: {\r\n            total: 0,\r\n            static: 0,\r\n            dynamic: 0,\r\n            rectangleMaps: 0,\r\n            polygonMaps: 0,\r\n            circleMaps: 0,\r\n            lineMaps: 0,\r\n            containerMaps: 0,\r\n            tilemapMaps: 0,\r\n            matterMaps: 0\r\n        }\r\n     };\r\n\r\n    /**\r\n    * Raycaster's bounding box. By default it's size is based on Arcade Physics / Matter physics world bounds.\r\n    * If world size will change after creation of Raycaster, bounding box needs to be updated.\r\n    *\r\n    * @name Raycaster#boundingBox\r\n    * @type {Phaser.Geom.Rectangle}\r\n    * @default false\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.boundingBox = false;\r\n    /**\r\n    * Array of mapped game objects.\r\n    *\r\n    * @name Raycaster#mappedObjects\r\n    * @type {object[]}\r\n    * @since 0.6.0\r\n    */\r\n    this.mappedObjects = [];\r\n    /**\r\n    * Array of dynamic mapped game objects.\r\n    *\r\n    * @name Raycaster#dynamicMappedObjects\r\n    * @type {object[]}\r\n    * @since 0.10.6\r\n    */\r\n     this.dynamicMappedObjects = [];\r\n    /**\r\n    * Number of segments of circle maps.\r\n    *\r\n    * @name Raycaster#mapSegmentCount\r\n    * @type {number}\r\n    * @default 0\r\n    * @since 0.6.0\r\n    */\r\n    this.mapSegmentCount = 0;\r\n\r\n    if(options !== undefined) {\r\n        if(options.boundingBox === undefined && options.scene !== undefined) {\r\n            if(options.scene.physics !== undefined)\r\n                options.boundingBox = options.scene.physics.world.bounds;\r\n            else if(options.scene.matter !== undefined) {\r\n                let walls = options.scene.matter.world.walls;\r\n\r\n                if(walls.top !== null) {\r\n                    options.boundingBox = new Phaser.Geom.Rectangle(\r\n                        walls.top.vertices[3].x,\r\n                        walls.top.vertices[3].y,\r\n                        walls.bottom.vertices[1].x - walls.top.vertices[3].x,\r\n                        walls.bottom.vertices[1].y - walls.top.vertices[3].y\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setOptions(options);\r\n\r\n        if(options.autoUpdate === undefined || options.autoUpdate)\r\n            //automatically update event\r\n            this.scene.events.on('update', this.update, this);\r\n    }\r\n    else\r\n        //automatically update event\r\n        this.scene.events.on('update', this.update, this);\r\n\r\n    return this;\r\n}\r\n\r\nRaycaster.prototype = {\r\n    /**\r\n    * Configure raycaster.\r\n    *\r\n    * @method Raycaster#setOptions\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\r\n    * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n    * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps.\r\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\r\n    * @param {boolean|object} [options.debug] - Enable debug mode or cofigure {@link Raycaster#debugOptions debugOptions}.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setOptions: function(options) {\r\n        if(options.scene !== undefined) {\r\n            this.scene = options.scene;\r\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n            this.graphics.setDepth(999);\r\n        }\r\n\r\n        if(options.debug !== undefined && options.debug !== false) {\r\n            this.debugOptions.enabled = true;\r\n\r\n            if(typeof options.debug === 'object')\r\n                Object.assign(this.debugOptions, options.debug);\r\n        }\r\n\r\n        if(options.mapSegmentCount !== undefined)\r\n            this.mapSegmentCount = options.mapSegmentCount;\r\n\r\n        if(options.objects !== undefined)\r\n            this.mapGameObjects(options.objects);\r\n\r\n        if(options.boundingBox !== undefined)\r\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Set Raycaster's bounding box.\r\n    *\r\n    * @method Raycaster#setBoundingBox\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {number} x - The X coordinate of the top left corner of bounding box.\r\n    * @param {number} y - The Y coordinate of the top left corner of bounding box.\r\n    * @param {number} width - The width of bounding box.\r\n    * @param {number} height - The height of bounding box.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setBoundingBox: function(x, y, width, height) {\r\n        this.boundingBox = {\r\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\r\n            points: [],\r\n            segments: []\r\n        }\r\n        //set points\r\n        let points = [\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\r\n        ];\r\n\r\n        this.boundingBox.points = points;\r\n\r\n        //set segments\r\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\r\n            if(i+1 < length)\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n            else\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n        }\r\n    },\r\n\r\n    /**\r\n    * Map game objects\r\n    *\r\n    * @method Raycaster#mapGameObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object|object[]} objects - Game object / matter body or array of game objects / matter bodies to map.\r\n    * @param {boolean} [dynamic = false] - {@link Raycaster.Map Raycaster.Map} dynamic flag (determines map will be updated automatically).\r\n    * @param {object} [options] - Additional options for {@link Raycaster.Map Raycaster.Map}\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    mapGameObjects: function(objects, dynamic = false, options = {}) {\r\n        options.dynamic = dynamic;\r\n        options.segmentCount = (options.segmentCount !== undefined) ? options.segmentCount : this.segmentCount;\r\n\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            if(this.mappedObjects.includes(object))\r\n                continue;\r\n\r\n            //if object is not supported\r\n            if(object.data && object.data.get('raycasterMapNotSupported'))\r\n                continue;\r\n\r\n            let config = {};\r\n            for(let option in options) {\r\n                config[option] = options[option];\r\n            }\r\n            config.object = object;\r\n            \r\n            let map = new this.Map(config, this);\r\n            \r\n            if(map.notSupported) {\r\n                map.destroy();\r\n                continue;\r\n            }\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                object.raycasterMap = map;\r\n            }\r\n            else if(!object.data) {\r\n                object.setDataEnabled();\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n            else {\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n\r\n            this.mappedObjects.push(object);\r\n\r\n            //update stats            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps++;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps++;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps++;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps++;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps++;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps++;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n        this._stats.mappedObjects.static = this._stats.mappedObjects.total - this.dynamicMappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Remove game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#removeMappedObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be removed.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    removeMappedObjects: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n\r\n        for(let object of objects) {\r\n            //remove object from mapped objects list\r\n            let index = this.mappedObjects.indexOf(object);\r\n            if(index === -1) {\r\n                continue;\r\n            }\r\n            \r\n            this.mappedObjects.splice(index, 1);\r\n            \r\n            //remove object from dynamic mapped objects list\r\n            index = this.dynamicMappedObjects.indexOf(object);\r\n            if(index >= 0)\r\n                this.dynamicMappedObjects.splice(index, 1);\r\n            \r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                object.raycasterMap.destroy();\r\n            }\r\n            else {\r\n                object.data.get('raycasterMap').destroy();\r\n            }\r\n            \r\n            //update stats            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps--;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps--;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps--;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps--;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps--;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps--;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n        this._stats.mappedObjects.dynamic = this.dynamicMappedObjects.length;\r\n        this._stats.mappedObjects.static = this._stats.mappedObjects.total - this.dynamicMappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Enable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#enableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be enabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    enableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = true;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Disable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#disableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be disabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    disableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Updates all {@link Raycaster.Map Raycaster.Map} dynamic maps. Fired on Phaser.Scene update event.\r\n    *\r\n    * @method Raycaster#update\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    update: function() {\r\n        //update dynamic maps\r\n        if(this.dynamicMappedObjects.length > 0) {\r\n            for(let mapppedObject of this.dynamicMappedObjects) {\r\n                let map;\r\n\r\n                if(mapppedObject.type === 'body' || mapppedObject.type === 'composite') {\r\n                    map = mapppedObject.raycasterMap;\r\n                }\r\n                else if(mapppedObject.data) {\r\n                    map = mapppedObject.data.get('raycasterMap');\r\n                }\r\n\r\n                if(!map)\r\n                    continue;\r\n\r\n                if(map.active) {\r\n                    map.updateMap();\r\n                }\r\n            }\r\n        }\r\n\r\n        //debug\r\n        if(this.debugOptions.enabled)\r\n            this.drawDebug();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Create {@link Raycaster.Ray Raycaster.Ray} object.\r\n    *\r\n    * @method Raycaster#createRay\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Ray's congfiguration options. May include:\r\n    * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\r\n    * @param {number} [options.angle = 0] - Ray's angle in radians.\r\n    * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\r\n    * @param {number} [options.cone = 0] - Ray's cone angle in radians.\r\n    * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\r\n    * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n    * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\r\n    * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\r\n    * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n    * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n    * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\r\n    * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\r\n    *\r\n    * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n    */\r\n    createRay: function(options = {}) {\r\n        return new this.Ray(options, this);\r\n    },\r\n\r\n    /**\r\n    * Get raycaster statistics.\r\n    *\r\n    * @method Raycaster#getStats\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.10.0\r\n    *\r\n    * @return {object} Raycaster statistics.\r\n    */\r\n    getStats: function() {\r\n        return this._stats;\r\n    },\r\n\r\n    /**\r\n    * Draw maps in debug mode\r\n    *\r\n    * @method Raycaster#drawDebug\r\n    * @memberof Raycaster\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n     drawDebug: function() {\r\n        if(this.graphics === undefined || !this.debugOptions.enabled)\r\n            return this;\r\n\r\n        //clear\r\n        this.graphics.clear();\r\n\r\n        if(!this.debugOptions.maps)\r\n            return this;\r\n            \r\n        for(let object of this.mappedObjects)\r\n        {\r\n            let map;\r\n        \r\n            if(object.type === 'body' || object.type === 'composite')\r\n                map = object.raycasterMap;\r\n            else if(object.data)\r\n                map = object.data.get('raycasterMap');\r\n            \r\n            if(!map)\r\n                continue;\r\n\r\n            //draw bounding box\r\n            if(this.debugOptions.graphics.mapBoundingBox) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapBoundingBox);\r\n                this.graphics.strokeRectShape(map.getBoundingBox());\r\n            }\r\n\r\n            //draw segments\r\n            if(this.debugOptions.graphics.mapSegment) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapSegment);\r\n                for(let segment of map.getSegments()) {\r\n                    this.graphics.strokeLineShape(segment);\r\n                }\r\n            }\r\n\r\n            //draw points\r\n            if(this.debugOptions.graphics.mapPoint) {\r\n                this.graphics.fillStyle(this.debugOptions.graphics.mapPoint);\r\n                for(let point of map.getPoints()) {\r\n                    this.graphics.fillPoint(point.x, point.y, 3)\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Destroy object and all mapped objects.\r\n     *\r\n     * @method Raycaster#destroy\r\n     * @memberof Raycaster\r\n     * @instance\r\n     * @since 0.10.3\r\n     */\r\n    destroy: function() {\r\n        this.removeMappedObjects(this.mappedObjects);\r\n        \r\n        if(this.graphics)\r\n            this.graphics.destroy();\r\n        \r\n        if(this.scene) {\r\n            this.scene.events.removeListener('update', null, this);\r\n        }\r\n\r\n        for(let key in this) {\r\n            delete this[key];\r\n        }\r\n    }\r\n}\r\n\r\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\r\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\r\n", "// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n", "// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};", "__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }", "// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};", "// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(781);\n"],
  "mappings": "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",
  "names": ["root", "factory", "exports", "module", "define", "amd", "self", "e", "t", "i", "n", "r", "PhaserRaycaster", "scene", "pluginManager", "_this", "_callSuper", "_Raycaster", "require", "Phaser", "Plugins", "ScenePlugin", "key", "value", "options", "arguments", "length", "this", "s", "getBoundingBox", "object", "getBounds", "rectangle", "line", "polygon", "arc", "container", "tilemap", "matterBody", "segmentCount", "boundingBox", "config", "type", "getPoints", "getSegments", "updateMap", "circle", "setSegmentCount", "mapChild", "_circles", "_updateChildMap", "collisionTiles", "setCollisionTiles", "setOrigin", "forceConvex", "forceVerticesMapping", "notSupported", "dynamic", "active", "destroy", "raycasterMap", "data", "remove", "o", "a", "ray", "_points", "points", "offset", "Geom", "Point", "x", "displayWidth", "originX", "y", "displayHeight", "originY", "c", "rayA", "Line", "rayB", "rotation", "vector", "SetToAngle", "Angle", "Length", "cB", "getPointB", "origin", "rayLength", "Math", "sqrt", "pow", "radius", "scaleX", "angle", "dAngle", "asin", "push", "neighbours", "_segments", "scaleY", "geom", "segments", "_step", "newPoints", "_iterator", "_createForOfIteratorHelper", "done", "point", "err", "f", "_step2", "_iterator2", "prevPoint", "slice", "nextPoint", "h", "isChild", "iterate", "child", "bind", "iLength", "list", "childA", "mapA", "get", "j", "jLength", "childB", "mapB", "Intersects", "RectangleToRectangle", "_step3", "segmentA", "_iterator3", "segmentB", "intersection", "LineToLine", "setDataEnabled", "map", "constructor", "set", "_step4", "childPoints", "_iterator4", "childPoint", "previousPoint", "_step5", "_iterator5", "segment", "pointA", "getPointA", "pointB", "vectorA", "vectorB", "circleOffset", "Circle", "_step6", "_iterator6", "childMapCircle", "Map", "raycaster", "_raycaster", "_dynamic", "prototype", "dynamicMappedObjects", "_stats", "mappedObjects", "static", "total", "index", "indexOf", "splice", "body", "circleRadius", "position", "scale", "bodies", "generateBounds", "bounds", "bodyItem", "parts", "vertices", "indexedPoints", "part", "isInternal", "_i2", "_parts", "matter", "composite", "Rectangle", "min", "max", "closePath", "pop", "shift", "getTopLeft", "getTopRight", "getBottomRight", "getBottomLeft", "detectionRange", "MAX_SAFE_INTEGER", "Distance", "Between", "x1", "y1", "x2", "y2", "LineToCircle", "detectionRangeCircle", "columns", "Array", "layer", "startPoint", "endPoint", "row", "tileWidth", "tileHeight", "includes", "tile", "higherRow", "column", "tiles", "count", "setAngle", "Normalize", "_ray", "rayRange", "setAngleDeg", "DegToRad", "cast", "closestIntersection", "closestSegment", "closestObject", "closestDistance", "internal", "startTime", "performance", "now", "stats", "method", "rays", "testedMappedObjects", "hitMappedObjects", "time", "intersections", "GetLineToRectangle", "distance", "target", "objects", "result", "boundingBoxIntersections", "canTestMap", "_boundingBox", "setTo", "width", "height", "ContainsPoint", "boundingBoxIntersection", "Equals", "isTangent", "circleIntersections", "GetLineToCircle", "_step7", "_iterator7", "_step8", "_iterator8", "_step9", "_iterator9", "ignoreNotIntersectedRays", "round", "drawDebug", "castCircle", "originalAngle", "maps", "rayTargets", "testedObjects", "boundsInRange", "objectB", "sort", "b", "previousTarget", "_i", "_rayTargets", "castSides", "roundedTarget", "BetweenPoints", "triangleIntersections", "neighboursTriangle", "Triangle", "GetTriangleToLine", "_triangleIntersection", "triangleIntersection", "abs", "intersectionA", "intersectionB", "autoSlice", "slicedIntersections", "castCone", "minAngle", "maxAngle", "cone", "coneDeg", "angleOffsetDeg", "RadToDeg", "ShortestBetween", "setCone", "setConeDeg", "angleDeg", "collisionRange", "enablePhysics", "debugOptions", "enabled", "graphics", "add", "lineStyle", "color", "fillStyle", "setDepth", "clear", "strokeLineShape", "rayPoint", "fillPoint", "collisionCircle", "bodyType", "gameObject", "shape", "centerX", "centerY", "label", "isSensor", "ignoreGravity", "setOnCollideActive", "physics", "existing", "setCircle", "setAllowGravity", "setImmovable", "setCollisionCategory", "collisionFilter", "category", "setCollisionGroup", "group", "setCollidesWith", "categories", "flags", "isArray", "mask", "setOnCollide", "callback", "onCollideCallback", "collisionInfo", "rayCollided", "processOverlap", "setOnCollideEnd", "onCollideEndCallback", "onCollideActiveCallback", "bodyA", "bodyB", "onCollideWith", "id", "setOnCollideWith", "func", "src", "hasOwnProperty", "overlap", "targets", "overlapCircle", "query", "collides", "getMatterBodies", "testMatterOverlap", "overlapCirc", "hitbox", "isCircle", "halfWidth", "testArcadeOverlap", "CircleToCircle", "CircleToRectangle", "object1", "object2", "obj1", "obj2", "TriangleToCircle", "RectangleToTriangle", "TriangleToLine", "setRayRange", "setDetectionRange", "setCollisionRange", "oldRangeMax", "setRadius", "isStatic", "objectBounds", "Ray", "getStats", "setRay", "closed", "slices", "Raycaster", "version", "mapPoint", "mapSegment", "mapBoundingBox", "rectangleMaps", "polygonMaps", "circleMaps", "lineMaps", "containerMaps", "tilemapMaps", "matterMaps", "mapSegmentCount", "world", "walls", "top", "bottom", "setOptions", "autoUpdate", "events", "on", "update", "debug", "_typeof", "Object", "assign", "mapGameObjects", "setBoundingBox", "left", "right", "option", "removeMappedObjects", "enableMaps", "disableMaps", "mapppedObject", "createRay", "strokeRectShape", "removeListener", "__webpack_module_cache__", "__webpack_require__", "moduleId", "cachedModule", "__webpack_modules__", "d", "definition", "defineProperty", "enumerable", "obj", "prop", "call", "Symbol", "toStringTag"]
}
